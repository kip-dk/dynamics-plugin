/*
 * Kipon.Xrm.Tools version 1.0.5.2, Kipon.Xrm for SOLID plugins. Â© Kipon ApS, 2019, 2020.
 * 
 * This code was auto-generated by accumulating the Kipon.Xrm functionality of Kipon.Solid.Plugin namespace into
 * a single distributable source.
 *
 * It is against the license terms to change the namespace of any classes in this source.
 *
 * Any use of this code is on you own risk. Kipon ApS does not take any responsibility on issues caused or related to the use of this code.
 */
#region source: ..\..\Kipon.Solid.Plugin\Xrm\ActionTarget.cs

namespace Kipon.Tools.Xrm
{
    public interface ActionTarget<T> where T: Microsoft.Xrm.Sdk.Entity
    {
        Microsoft.Xrm.Sdk.EntityReference Target { get; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\BasePlugin.cs
namespace Kipon.Tools.Xrm
{
    using System;
    using System.Linq;
    using Microsoft.Xrm.Sdk;
    public class BasePlugin : IPlugin
    {
        public const string Version = "1.0.5.2";
        public string UnsecureConfig { get; private set; }
        public string SecureConfig { get; private set; }

        internal static readonly Reflection.PluginMethod.Cache PluginMethodCache;

        static BasePlugin()
        {
            PluginMethodCache = new Reflection.PluginMethod.Cache(typeof(BasePlugin).Assembly);
            Reflection.Types.Instance.SetAssembly(typeof(BasePlugin).Assembly);
        }

        #region constructors
        public BasePlugin() : base()
        {
        }

        public BasePlugin(string unSecure, string secure) : this()
        {
            this.UnsecureConfig = unSecure;
            this.SecureConfig = secure;
        }
        #endregion

        #region iplugin impl
        public void Execute(IServiceProvider serviceProvider)
        {
            var context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
            var serviceFactory = (IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory));

            var toolOrgService = serviceFactory.CreateOrganizationService(null);

            var tracingService = (ITracingService)serviceProvider.GetService(typeof(ITracingService));
            var userId = context.UserId;
            var message = context.MessageName;
            var stage = context.Stage;
            var isAsync = context.Mode == 1;

            var type = message.Contains("_") ? CrmEventType.CustomPlugin : (CrmEventType)Enum.Parse(typeof(CrmEventType), context.MessageName);

            IPluginContext pluginContext = new Services.PluginContext(this.UnsecureConfig, this.SecureConfig, context, type, userId);

            using (var serviceCache = new Reflection.ServiceCache(context, serviceFactory, tracingService, pluginContext, this.UnsecureConfig, this.SecureConfig))
            {
                var entityName = context.PrimaryEntityName;

                if (entityName == "none" || Reflection.Types.MESSAGE_WITHOUT_PRIMARY_ENTITY.Contains(message))
                {
                    entityName = null;
                }

                var methods = PluginMethodCache.ForPlugin(this.GetType(), stage, message, entityName, context.Mode == 1);

                var logs = new System.Collections.Generic.List<string>();
                try
                {
                    foreach (var method in methods)
                    {
                        var nextlog = $"{method.Name}(";
                        #region find out if method is relevant, looking a target fields
                        if (message == Attributes.StepAttribute.MessageEnum.Update.ToString() && !method.FilterAllProperties)
                        {
                            var targetEntity = (Microsoft.Xrm.Sdk.Entity)context.InputParameters["Target"];
                            if (!method.IsRelevant(targetEntity))
                            {
                                continue;
                            }
                        }
                        #endregion

                        #region now resolve all parameters
                        var args = new object[method.Parameters.Length];
                        var ix = 0;
                        System.ComponentModel.INotifyPropertyChanged mergedimage = null;
                        System.ComponentModel.INotifyPropertyChanged target = null;
                        var comma = "";
                        foreach (var p in method.Parameters)
                        {
                            nextlog += $"{comma}{p?.FromType?.FullName}";
                            comma = ", ";
                            if (p.IsInputParameter)
                            {
                                if (context.InputParameters.ContainsKey(p.Name))
                                {
                                    args[ix] = context.InputParameters[p.Name];
                                }
                                else
                                {
                                    if (p.Name != null)
                                    {
                                        if (p.Name.ToLower() == nameof(this.UnsecureConfig).ToLower())
                                        {
                                            args[ix] = this.UnsecureConfig;
                                        }
                                        else
                                        if (p.Name.ToLower() == nameof(this.SecureConfig).ToLower())
                                        {
                                            args[ix] = this.SecureConfig;
                                        }
                                        else
                                        {
                                            args[ix] = null;
                                        }
                                    }
                                    else
                                    {
                                        args[ix] = null;
                                    }
                                }
                            }
                            else
                            {
                                args[ix] = serviceCache.Resolve(p, toolOrgService);
                            }

                            if (stage <= 20 && message == "Update")
                            {
                                if (p.IsMergedimage)
                                {
                                    mergedimage = (System.ComponentModel.INotifyPropertyChanged)args[ix];
                                }

                                if (p.IsTarget)
                                {
                                    target = args[ix] as System.ComponentModel.INotifyPropertyChanged;
                                }
                            }
                            ix++;
                        }
                        #endregion

                        #region add mergedimage eventlistener if applicable
                        PropertyMirror mergedimageMirror = null;
                        PropertyMirror targetMirror = null;

                        if (stage <= 20 && message == "Update")
                        {
                            if (mergedimage != null)
                            {
                                var tg = (Microsoft.Xrm.Sdk.Entity)context.InputParameters["Target"];
                                mergedimageMirror = new PropertyMirror(tg);
                                mergedimage.PropertyChanged += mergedimageMirror.MirrorpropertyChanged;
                            }

                            if (mergedimage != null && target != null)
                            {
                                targetMirror = new PropertyMirror((Microsoft.Xrm.Sdk.Entity)mergedimage);
                                target.PropertyChanged += targetMirror.MirrorpropertyChanged;
                            }
                        }
                        #endregion

                        #region run the method
                        var inError = false;
                        nextlog += ")";
                        try
                        {
                            logs.Add($"before: {nextlog}");
                            var result = method.Invoke(this, args);
                            logs.Add($"after: {nextlog}");

                            if (result != null && method.OutputProperties != null && method.OutputProperties.Count > 0)
                            {
                                foreach (var key in method.OutputProperties.Keys)
                                {
                                    var output = method.OutputProperties[key];
                                    var value = key.GetValue(result);
                                    if (value != null)
                                    {
                                        #region map strongly typed entities back to base entities to allow correct serrialization back to client
                                        if (value is Microsoft.Xrm.Sdk.Entity e && value.GetType() != typeof(Microsoft.Xrm.Sdk.Entity))
                                        {
                                            var entity = new Microsoft.Xrm.Sdk.Entity(e.LogicalName, e.Id);
                                            entity.Attributes = e.Attributes;
                                            value = entity;
                                        }

                                        if (value is Microsoft.Xrm.Sdk.EntityCollection ec && ec.Entities != null && ec.Entities.Count > 0)
                                        {
                                            var final = new Microsoft.Xrm.Sdk.EntityCollection { EntityName = ec.EntityName };
                                            foreach (var ent in ec.Entities)
                                            {
                                                if (ent.GetType() == typeof(Microsoft.Xrm.Sdk.Entity))
                                                {
                                                    final.Entities.Add(ent);
                                                }
                                                else
                                                {
                                                    var entity = new Microsoft.Xrm.Sdk.Entity(ent.LogicalName, ent.Id);
                                                    entity.Attributes = ent.Attributes;
                                                    final.Entities.Add(entity);
                                                }
                                            }
                                            value = final;
                                        }
                                        #endregion

                                        context.OutputParameters[output.LogicalName] = value;
                                    }
                                }
                            }
                        }
                        catch (Microsoft.Xrm.Sdk.InvalidPluginExecutionException)
                        {
                            inError = true;
                            throw;
                        }
                        catch (System.Reflection.TargetInvocationException te)
                        {
                            inError = true;
                            if (te.InnerException != null && te.InnerException is Microsoft.Xrm.Sdk.InvalidPluginExecutionException)
                            {
                                throw te.InnerException;
                            }

                            if (te.InnerException != null)
                            {
                                throw new InvalidPluginExecutionException(te.InnerException.Message, te.InnerException);
                            }

                            throw new InvalidPluginExecutionException(te.Message, te);
                        }
                        catch (Exception be)
                        {
                            inError = true;
                            if (be.GetType().BaseType?.FullName == "Kipon.Xrm.Exceptions.BaseException")
                            {
                                // it is not a unit test, its the real thing, so we map the exception to a supported exception to allow message to parse all the way to the client
                                throw new InvalidPluginExecutionException($"{be.GetType().FullName}: {be.Message}", be);
                            }

                            throw new InvalidPluginExecutionException(be.Message, be);
                        }
                        finally
                        {
                            if (!inError)
                            {
                                #region cleanup mirror
                                if (stage <= 20)
                                {
                                    if (mergedimageMirror != null)
                                    {
                                        mergedimage.PropertyChanged -= mergedimageMirror.MirrorpropertyChanged;
                                        mergedimageMirror = null;
                                    }

                                    if (targetMirror != null)
                                    {
                                        target.PropertyChanged -= targetMirror.MirrorpropertyChanged;
                                        targetMirror = null;
                                    }
                                }
                                #endregion

                                #region prepare for next method
                                serviceCache.OnStepFinalize();
                                #endregion
                            }
                        }
                        #endregion
                    }
                } catch (Exception)
                {
                    foreach (var l in logs)
                    {
                        tracingService.Trace(l);
                    }
                    throw;
                }
            }
        }
        #endregion

        #region image helper classes
        private class PropertyMirror
        {
            private Microsoft.Xrm.Sdk.Entity mirrorTo;

            internal PropertyMirror(Microsoft.Xrm.Sdk.Entity mirrorTo)
            {
                this.mirrorTo = mirrorTo; 
            }

            internal void MirrorpropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
            {
                var prop = sender.GetType().GetProperty(e.PropertyName);
                if (prop != null)
                {
                    var attr = (Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute)prop.GetCustomAttributes(typeof(Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute), false).FirstOrDefault();
                    if (attr != null)
                    {
                        var source = sender as Microsoft.Xrm.Sdk.Entity;
                        if (source != null)
                        {
                            mirrorTo[attr.LogicalName] = source[attr.LogicalName];
                        }
                    }
                }
            } 
        }
        #endregion
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\CrmEventType.cs
namespace Kipon.Tools.Xrm
{
    public enum CrmEventType
    {
        Create,
        Update,
        Delete,
        Associate,
        Disassociate,
        SetState,
        SetStateDynamicEntity,
        RetrieveMultiple,
        Retrieve,
        Other,
        AddMember,
        AddListMembers,
        RemoveMember,

        QualifyLead,

        CustomPlugin
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\IAdminUnitOfWork.cs
namespace Kipon.Tools.Xrm
{
    public interface IAdminUnitOfWork : IUnitOfWork
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\IPluginContext.cs
namespace Kipon.Tools.Xrm
{
    using System;

    public interface IPluginContext
    {
        string UnsecureConfig { get; }
        string SecureConfig { get; }
        Guid UserId { get; }
        CrmEventType EventType { get; }
        bool AttributeChanged(params string[] names);
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\IRepository.cs
namespace Kipon.Tools.Xrm
{
    using System;
    using System.Linq;

    /// <summary>
    /// Interface for generic repository implementations.
    /// </summary>
    public interface IRepository<T> where T: Microsoft.Xrm.Sdk.Entity, new()
    {
        /// <summary>
        /// Gets an <see cref="IQueryable{T}"/> to perform further operations.
        /// </summary>
        /// <returns>An <see cref="IQueryable{T}"/>.</returns>
        IQueryable<T> GetQuery();

        T GetById(Guid id);

        /// <summary>
        /// Deletes the given entity.
        /// </summary>
        /// <param name="entity">The entity to delete.</param>
        void Delete(T entity);

        /// <summary>
        /// Adds the given entity.
        /// </summary>
        /// <param name="entity">The entity to add.</param>
        void Add(T entity);

        /// <summary>
        /// Updates the given entity.
        /// </summary>
        /// <param name="entity">The entity to update.</param>
        void Update(T entity);

        /// <summary>
        /// Attaches the the given entity to the current context.
        /// </summary>
        /// <param name="entity">The entity to attach.</param>
        void Attach(T entity);


        /// <summary>
        /// Detach the object from the context
        /// </summary>
        /// <param name="entity"></param>
        void Detach(T entity);

    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\IService.cs
namespace Kipon.Tools.Xrm
{
    public interface IService
    {
        void OnStepFinalized();
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\ITarget.cs
namespace Kipon.Tools.Xrm
{
    public interface ITarget 
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\IUnitOfWork.cs
namespace Kipon.Tools.Xrm
{
    using Microsoft.Xrm.Sdk;
    using System;
    public interface IUnitOfWork
    {
        R ExecuteRequest<R>(OrganizationRequest request) where R : OrganizationResponse;
        OrganizationResponse Execute(OrganizationRequest request);
        System.Guid Create(Entity entity);
        void Update(Entity entity);
        void Delete(Entity entity);
        void ClearContext();
        void Detach(string logicalname, params Guid[] ids);
        void Detach(Microsoft.Xrm.Sdk.EntityReference reference);
        void Detach(Microsoft.Xrm.Sdk.Entity entity);
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Mergedimage.cs
namespace Kipon.Tools.Xrm
{
    // Declarative interface to request a merged image
    // A merged image takes the target of a plugin, and combine it with the field available in the target.
    // A merged image should
    // In pre stage, a merged image is keept in sync. with the target, so any change to the target will reflect in the merged image, AND vise-versa.
    public interface Mergedimage<T> where T: Microsoft.Xrm.Sdk.Entity
    {
        System.Guid Id { get; }
        string LogicalName { get; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Postimage.cs
namespace Kipon.Tools.Xrm
{
    // Represent a post image
    // an extension should only expose getters, because any change will not be send back to crm
    public interface Postimage<T> where T: Microsoft.Xrm.Sdk.Entity
    {
        System.Guid Id { get; }
        string LogicalName { get; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Preimage.cs
namespace Kipon.Tools.Xrm
{
    // Declarativ interface to represent a pre image.
    // any extension should only have get properties, because any change will not be pushed back to the server
    public interface Preimage<T> where T: Microsoft.Xrm.Sdk.Entity
    {
        System.Guid Id { get; }
        string LogicalName { get; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Target.cs
namespace Kipon.Tools.Xrm
{

    /// <summary>
    /// Declarativ inteface to represent the target of a plugin
    /// Any extension can have getters and setters, and if changed in a pre process, any change will be send back
    /// to the server together with the initial state of the target
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface Target<T> where T: Microsoft.Xrm.Sdk.Entity
    {
        System.Guid Id { get; }
        string LogicalName { get; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\TargetReference.cs
namespace Kipon.Tools.Xrm
{
    using System;
    public abstract class TargetReference<T> where T: Microsoft.Xrm.Sdk.Entity
    {
        private Microsoft.Xrm.Sdk.EntityReference target;

        public TargetReference(Microsoft.Xrm.Sdk.EntityReference target)
        {
            if (target.LogicalName != this._logicalName)
            {
                throw new ArgumentException($"Target reference does not match this type, expected {_logicalName} got {target.LogicalName }");
            }
            this.target = target;
        }

        public Microsoft.Xrm.Sdk.EntityReference Value
        {
            get
            {
                return this.target;
            }
        }

        protected abstract string _logicalName { get; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\VirtualEntityPlugin.cs
namespace Kipon.Tools.Xrm
{
    using System;
    using System.Linq;
    using Microsoft.Xrm.Sdk;
    using Microsoft.Xrm.Sdk.Extensions;

    public class VirtualEntityPlugin : Microsoft.Xrm.Sdk.IPlugin
    {
        public string UnsecureConfig { get; private set; }
        public string SecureConfig { get; private set; }

        internal static readonly Reflection.PluginMethod.Cache PluginMethodCache;

        static VirtualEntityPlugin()
        {
            PluginMethodCache = new Reflection.PluginMethod.Cache(typeof(BasePlugin).Assembly);
            Reflection.Types.Instance.SetAssembly(typeof(BasePlugin).Assembly);
        }

        #region constructors
        public VirtualEntityPlugin() : base()
        {
        }

        public VirtualEntityPlugin(string unSecure, string secure) : this()
        {
            this.UnsecureConfig = unSecure;
            this.SecureConfig = secure;
        }
        #endregion


        public void Execute(IServiceProvider serviceProvider)
        {
            var context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
            var serviceFactory = (IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory));
            var tracingService = (ITracingService)serviceProvider.GetService(typeof(ITracingService));

            var userId = context.UserId;
            var message = context.MessageName;

            if (message != "Retrieve" && message != "RetrieveMultiple")
            {
                throw new InvalidPluginExecutionException($"Unsupported message in VirtualEntityPlugin { message }. Only Retrieve and RetrieveMultiple is supported");
            }

            var type = (CrmEventType)Enum.Parse(typeof(CrmEventType), context.MessageName);

            IPluginContext pluginContext = new Services.PluginContext(this.UnsecureConfig, this.SecureConfig, context, type, userId);

            IOrganizationService toolOrgService = null;


            if (type == CrmEventType.Retrieve || type == CrmEventType.RetrieveMultiple)
            {
                toolOrgService = serviceFactory.CreateOrganizationService(null);
            }

            using (var serviceCache = new Reflection.ServiceCache(context, serviceFactory, tracingService, pluginContext, this.UnsecureConfig, this.SecureConfig))
            {
                var method = PluginMethodCache.ForPlugin(this.GetType(), 30, message, context.PrimaryEntityName, context.Mode == 1).Single();

                var args = new object[method.Parameters.Length];

                var ix = 0;

                Microsoft.Xrm.Sdk.Entity datasource = null;

                foreach (var p in method.Parameters)
                {
                    if (p.Name != null && p.Name.ToLower() == "datasource")
                    {
                        if (datasource == null)
                        {
                            var ds = (IEntityDataSourceRetrieverService)serviceProvider.GetService(typeof(IEntityDataSourceRetrieverService));
                            datasource = ds.RetrieveEntityDataSource();

                            if (p.FromType.BaseType == typeof(Microsoft.Xrm.Sdk.Entity))
                            {
                                var tmp = (Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(p.FromType);
                                tmp.Attributes = datasource.Attributes;
                                datasource = tmp;
                            }
                        }
                        args[ix] = datasource;
                    }
                    else
                    {
                        args[ix] = serviceCache.Resolve(p, toolOrgService);
                    }
                    ix++;
                }

                var result = method.Invoke(this, args);
                if (result != null)
                {
                    if (message == "Retrieve")
                    {
                        var be = result as Microsoft.Xrm.Sdk.Entity;
                        if (be == null)
                        {
                            throw new InvalidPluginExecutionException("Return from virtual antity Retrieve must be of type Microsoft.Xrm.Sdk.Entity");
                        }

                        if (be.GetType() != typeof(Microsoft.Xrm.Sdk.Entity))
                        {
                            var fr = new Microsoft.Xrm.Sdk.Entity { Id = be.Id, LogicalName = be.LogicalName };
                            fr.Attributes = be.Attributes;
                            be = fr;
                        }

                        this.RemoveNullValues(be);
                        context.OutputParameters["BusinessEntity"] = be;
                    }

                    if (message == "RetrieveMultiple")
                    {
                        var bes = result as Microsoft.Xrm.Sdk.EntityCollection;
                        if (bes == null)
                        {
                            throw new InvalidPluginExecutionException("Return from virtual entity RetrieveMultiple must be of type Microsoft.Xrm.Sdk.EntityCollection");
                        }

                        var entities = bes.Entities.ToArray();
                        bes.Entities.Clear();


                        foreach (var be in entities)
                        {
                            if (be.GetType() == typeof(Microsoft.Xrm.Sdk.Entity))
                            {
                                bes.Entities.Add(be);
                            } else
                            {
                                var fr = new Microsoft.Xrm.Sdk.Entity { Id = be.Id, LogicalName = be.LogicalName };
                                fr.Attributes = be.Attributes;
                                bes.Entities.Add(fr);
                            }
                        }

                        foreach (var fe in bes.Entities)
                        {
                            this.RemoveNullValues(fe);
                        }
                        context.OutputParameters["BusinessEntityCollection"] = bes;
                    }
                }
            }
        }

        private void RemoveNullValues(Microsoft.Xrm.Sdk.Entity entity)
        {
            foreach (var k in entity.Attributes.Keys.ToArray())
            {
                var v = entity[k];
                if (v == null) entity.Attributes.Remove(k);
            }
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Actions\AbstractActionRequest.cs
namespace Kipon.Tools.Xrm.Actions
{
    using System;
    public abstract class AbstractActionRequest
    {
        private readonly Microsoft.Xrm.Sdk.IPluginExecutionContext ctx;
        public AbstractActionRequest(Microsoft.Xrm.Sdk.IPluginExecutionContext ctx)
        {
            this.ctx = ctx;
        }


        protected T ValueOf<T>(string name)
        {
            if (ctx.InputParameters.ContainsKey(name))
            {
                var value = ctx.InputParameters[name];
                return (T)value;
            }
            return default(T);
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\AdminAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;

    /// <summary>
    /// Property indicating that the underlying IOrganizationService must be run with system priviliges
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter, Inherited = false, AllowMultiple = false)]
    public class AdminAttribute : Attribute
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\ExportAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use Export attribute as decoration for interfaces with multi implementation to state the one and only to be used.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    public class ExportAttribute : Attribute
    {
        private Type type;
        public ExportAttribute(Type type)
        {
            this.type = type;
        }

        public Type Type
        {
            get
            {
                return this.type;
            }
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\ImportingConstructorAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use ImportingConstructor to decorate classes with multi public constructor, decorating the one and only constructor to be used to create the instance
    /// </summary>
    [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
    public class ImportingConstructorAttribute : Attribute
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\LogicalNameAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// For steps supporting multi entity types, decorate the method with one ore mote logical names to be supported
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Interface, AllowMultiple = true)]
    class LogicalNameAttribute : Attribute
    {
        public LogicalNameAttribute(string name)
        {
            this.Value = name;
        }

        public string Value
        {
            get; private set;
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\MergedimageAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use this attribute to state that the parameter should be populated with the MergedImage
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]
    public class MergedimageAttribute : Attribute
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\OutputAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;

    /// <summary>
    /// Property indicating that the underlying IOrganizationService must be run with system priviliges
    /// </summary>
    [AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
    public class OutputAttribute : Attribute
    {
        public string LogicalName { get; private set; }
        public bool Required { get; private set; }

        public OutputAttribute(string logicalName, bool required)
        {
            this.LogicalName = logicalName;
            this.Required = required;
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\PostimageAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use the attribute to state that the parameter should be populated with the post image
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]
    public class PostimageAttribute : Attribute
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\PreimageAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use the attribute to state the the parameter should be populated with the preimage
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]
    public class PreimageAttribute : Attribute
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\RequiredAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;

    [AttributeUsage(AttributeTargets.Property)]
    public class RequiredAttribute : Attribute
    {

        public RequiredAttribute()
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\SortAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use the parameter on plugin methods to indicate order of execution for methods triggered by the same event
    /// The lowest value for a plugin will be used as the deployment value as well.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class SortAttribute : Attribute
    {

        public SortAttribute(int value)
        {
            this.Value = value;
        }

        public int Value { get; private set; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\StepAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use this method in plugins to state that the method should be called as a step.
    /// The recommended approach is using naming conventions, but if for some reason this cannot be used, add the attribute to the method.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class StepAttribute : Attribute
    {

        public StepAttribute(StageEnum stage, MessageEnum message, string primaryEntityName)
        {
            this.Stage = (int)stage;
            this.Message = message.ToString();
            this.PrimaryEntityName = primaryEntityName;
        }

        public int Stage { get; private set; }
        public string Message { get; private set; }
        public string PrimaryEntityName { get; set; }

        public bool IsAsync
        {
            get
            {
                return this.Stage == (int)StageEnum.PostAsync;
            }
        }

        public enum StageEnum
        {
            Validate = 10,
            Pre = 20,
            Post = 40,
            PostAsync = 41
        }

        public enum MessageEnum
        {
            Create,
            Update,
            Delete,
            Associate,
            Disassociate,
            RetrieveMultiple,
            Retrieve,
            AddMember,
            AddListMembers,
            RemoveMember,
            Merge
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\TargetAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use this decoration to get target populated in the parameter
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]
    public class TargetAttribute : Attribute
    {
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Attributes\TargetFilterAttribute.cs
namespace Kipon.Tools.Xrm.Attributes
{
    using System;
    /// <summary>
    /// Use this attribute to decorate pre, post and merged image interface Properties to
    /// indicate that the property should also be part of the target filter. 
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Class, AllowMultiple = true)]
    public class TargetFilterAttribute : Attribute
    {

        /// <summary>
        /// Use this constructor when decorating properties. This constructor should not be used to decorate classes
        /// </summary>
        public TargetFilterAttribute()
        {
        }

        /// <summary>
        /// Use this constructor to decorate classes (only classes that inherits Microsoft.Xrm.Sdk.Entity is relevant),
        /// and the relation between an ITarget interface and the needed target attributes. 
        /// This constructor should not be used to decorate properties.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="attributes"></param>
        public TargetFilterAttribute(Type type, params string[] attributes)
        {
            this.Type = type;
            this.Attributes = attributes;
        }

        public Type Type { get; private set; }
        public string[] Attributes { get; private set; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\BaseException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;
    [Serializable]
    public class BaseException : Exception
    {
        public BaseException(string message): base(message) { }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\CircularDependencyException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class CircularDependencyException : BaseException
    {
        public CircularDependencyException(string path) : base($"Circular dependendy detected. Path: {path}.")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\InvalidConstructorServiceArgumentException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class InvalidConstructorServiceArgumentException : BaseException
    {
        public InvalidConstructorServiceArgumentException(System.Reflection.ConstructorInfo con, System.Reflection.ParameterInfo par) : base($"constructor on {con.DeclaringType.FullName} is requesting parameter types that are only available on plugin methods. Parse these arguments to service methods instead of constructor injection: { par.Name}")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\MultiImplementationOfSameInterfaceException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class MultiImplementationOfSameInterfaceException : BaseException
    {
        public MultiImplementationOfSameInterfaceException(Type type) : base($"{type.FullName} has more than one implementation. Mark the one to be used with export flag.")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\MultipleLogicalNamesException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class MultipleLogicalNamesException : BaseException
    {
        public MultipleLogicalNamesException(Type type, System.Reflection.MethodInfo method, string[] names) : base($"{ type.FullName }, method { method.Name } is requesting entities of different types. That is not allowed. {string.Join(",", names)}")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\TypeMismatchException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class TypeMismatchException : BaseException
    {
        public TypeMismatchException(Type fromType, Type toType) : base($"{toType.FullName} does not implement expected interface {fromType.FullName}")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\UnavailableImageException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class UnavailableImageException : BaseException
    {
        public UnavailableImageException(Type type, System.Reflection.MethodInfo method, string image, int stage, string message) : base($"{type.FullName}.{method.Name} is requesting image {image}. That is not supported in state {stage}, message {message}.")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\UnknownEntityTypeException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class UnknownEntityTypeException : BaseException
    {
        public UnknownEntityTypeException(string logicalname) : base($"{logicalname} cannot be converted to an early bound entity.")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\UnresolvableConstructorException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class UnresolvableConstructorException : BaseException
    {
        public UnresolvableConstructorException(Type type): base($"{type.FullName} has more than one constructor, mark exactly one of them with the (ImportingConstructor] attribute to indicate witch to use.)")
        {

        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\UnresolvablePluginMethodException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class UnresolvablePluginMethodException : BaseException
    {
        public UnresolvablePluginMethodException(Type type) : base($"{type.FullName} did not have any steps to be executed. Ether follow the naming convention for the plugin method, or add the [Step] custom attributes to methods to be executed")
        {

        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\UnresolvableTypeException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class UnresolvableTypeException : BaseException
    {
        public UnresolvableTypeException(Type fromType) : base($"{fromType.FullName} could not be resolved to a class with an available public constructor.")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\UnresolveableParameterException.cs
namespace Kipon.Tools.Xrm.Exceptions
{
    using System;

    [Serializable]
    public class UnresolveableParameterException : BaseException
    {
        public UnresolveableParameterException(Type type, string name) : base($"Parameter of type {type.FullName} name {name} could not be resolved to a value.")
        {
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Exceptions\UnresolvedQueryParameter.cs

namespace Kipon.Tools.Xrm.Exceptions
{
    public class UnresolvedQueryParameter : BaseException
    {
        public UnresolvedQueryParameter(string name) : base($"Unable to resolve {name} to a query expression.") { }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Extensions\IQueryable\QueryableMethods.cs
namespace Kipon.Tools.Xrm.Extensions.IQueryable
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Expressions;
    public static class IQueryableExtensions
    {
        public static IQueryable<TSource> WhereIn<TSource, TValue>(this IQueryable<TSource> source, Expression<Func<TSource, TValue>> valueSelector, IEnumerable<TValue> values)
        {
            if (null == source) { throw new ArgumentNullException("source"); }
            if (null == valueSelector) { throw new ArgumentNullException("valueSelector"); }
            if (null == values) { throw new ArgumentNullException("values"); }

            var equalExpressions = new List<BinaryExpression>();

            foreach (var value in values)
            {
                var equalsExpression = Expression.Equal(valueSelector.Body, Expression.Constant(value));
                equalExpressions.Add(equalsExpression);
            }

            ParameterExpression p = valueSelector.Parameters.Single();
            var combined = equalExpressions.Aggregate<Expression>((accumulate, equal) => Expression.Or(accumulate, equal));
            var combinedLambda = Expression.Lambda<Func<TSource, bool>>(combined, p);

            return source.Where(combinedLambda);
        }

        public static Expression<Func<TElement, bool>> BuildContainsExpression<TElement, TValue>(
            Expression<Func<TElement, TValue>> valueSelector,
            IEnumerable<TValue> values)
        {
            if (null == valueSelector) { throw new ArgumentNullException("valueSelector"); }
            if (null == values) { throw new ArgumentNullException("values"); }

            ParameterExpression p = valueSelector.Parameters.Single();

            if (!values.Any())
            {
                return e => false;
            }

            var equals = values.Select(value => (Expression)Expression.Equal(valueSelector.Body, Expression.Constant(value, typeof(TValue))));
            var body = equals.Aggregate<Expression>((accumulate, equal) => Expression.Or(accumulate, equal));

            return Expression.Lambda<Func<TElement, bool>>(body, p);
        }

        public static Expression<Func<TElement, bool>> BuildContainsNotExpression<TElement, TValue>(
            Expression<Func<TElement, TValue>> valueSelector,
            IEnumerable<TValue> values)
        {
            if (null == valueSelector) { throw new ArgumentNullException("valueSelector"); }
            if (null == values) { throw new ArgumentNullException("values"); }

            ParameterExpression p = valueSelector.Parameters.Single();

            if (!values.Any())
            {
                return e => false;
            }

            var equals = values.Select(value => (Expression)Expression.NotEqual(valueSelector.Body, Expression.Constant(value, typeof(TValue))));
            var body = equals.Aggregate<Expression>((accumulate, equal) => Expression.And(accumulate, equal));

            return Expression.Lambda<Func<TElement, bool>>(body, p);
        }

    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Extensions\QueryExpression\QueryExpressionMethods.cs
namespace Kipon.Tools.Xrm.Extensions.QueryExpression
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    public static class QueryExpressionMethods
    {
        public static string QuickFindFilter(this Microsoft.Xrm.Sdk.Query.QueryExpression query)
        {
            if (query.Criteria != null && query.Criteria.Filters != null && query.Criteria.Filters.Count > 0)
            {
                var qf = query.Criteria.Filters.Where(r => r.IsQuickFindFilter).SingleOrDefault();
                if (qf != null && qf.Conditions != null && qf.Conditions.Count > 0)
                {
                    var value = qf.Conditions[0].Values.Where(v => v is string).FirstOrDefault() as string;
                    if (!string.IsNullOrEmpty(value))
                    {
                        return value;
                    }
                }
            }
            return null;
        }

        public static T[] GetAttributeFilter<T>(this Microsoft.Xrm.Sdk.Query.QueryExpression query, string attributeLogicalName)
        {
            var results = new List<T>();

            void Resolve(Microsoft.Xrm.Sdk.Query.FilterExpression filter)
            {
                if (filter.Conditions != null && filter.Conditions.Count > 0)
                {
                    var condition = filter.Conditions.Where(r => r.AttributeName == attributeLogicalName).FirstOrDefault();
                    if (condition != null)
                    {
                        foreach (var v in condition.Values)
                        {
                            var resolved = false;
                            var t = v.ConvertValueTo<T>(out resolved);
                            if (resolved && t != null)
                            {
                                results.Add(t);
                            }
                        }
                    }
                }
            }

            if (query != null && query.Criteria != null && query.Criteria.Conditions != null && query.Criteria.Conditions.Count > 0)
            {
                Resolve(query.Criteria);
                if (results.Count > 0)
                {
                    return results.ToArray();
                }
            }

            if (query.Criteria != null && query.Criteria.Filters != null && query.Criteria.Filters.Count > 0)
            {
                foreach (var filter in query.Criteria.Filters.Where(r => r.Conditions != null && r.Conditions.Count > 0))
                {
                    Resolve(filter);
                    if (results.Count > 0)
                    {
                        return results.ToArray();
                    }
                }
            }
            return null;
        }

        public static Guid? GetIdFilter(this Microsoft.Xrm.Sdk.Query.QueryExpression query, string logicalName)
        {
            if (!string.IsNullOrEmpty(logicalName) && query != null && query.Criteria != null && query.Criteria.Filters != null && query.Criteria.Filters.Count > 0)
            {
                var idFilter = query.Criteria.Conditions.Where(r => r.AttributeName == $"{logicalName}id").FirstOrDefault();
                if (idFilter != null && idFilter.Values != null && idFilter.Values.Count == 1)
                {
                    return idFilter.Values.First().ConvertValueTo<Guid>(out bool resolved);
                }
            }
            return null;
        }

        public static T ConvertValueTo<T>(this object o, out bool resolved)
        {
            resolved = true;
            if (o == null) return default(T);

            if (o is T t) return t;

            {
                if (o is Microsoft.Xrm.Sdk.EntityReference er && typeof(T) == typeof(Guid))
                {
                    return (T)(object)er.Id;
                }
            }

            {
                if (o is Microsoft.Xrm.Sdk.OptionSetValue er && typeof(T) == typeof(int))
                {
                    return (T)(object)er.Value;
                }
            }

            {
                if (o is Microsoft.Xrm.Sdk.Money er && typeof(T) == typeof(decimal))
                {
                    return (T)(object)er.Value;
                }
            }


            resolved = false;
            return default(T);
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Extensions\Sdk\KiponSdkGeneratedExtensionMethods.cs
namespace Kipon.Tools.Xrm.Extensions.Sdk
{
    using System;
    using System.Linq;
    using System.Collections.Generic;
    using Microsoft.Xrm.Sdk;
    using Reflection;

    public static partial class KiponSdkGeneratedExtensionMethods
    {
        private static readonly Dictionary<string, Type> entittypes = new Dictionary<string, Type>();
        private static readonly Dictionary<string, System.Reflection.MethodInfo> TO_ENT_GENS = new Dictionary<string, System.Reflection.MethodInfo>();
        private static readonly System.Reflection.MethodInfo TO_ENTITY = typeof(Microsoft.Xrm.Sdk.Entity).GetMethod("ToEntity", new Type[0]);
        private static readonly Dictionary<string, string[]> targetattributes = new Dictionary<string, string[]>();

        public const string UNDEFINED_ATTRIBUTE_MESSAGE = "Entity of type {0} does not have a property named {1}";
        public const string MISSING_DECORATION_ATTRIBUTE_MESSAGE = "Property {0} on entity {1} is not decorated with Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute";

        private static readonly string[] CLONE_EXCLUDE = new string[]
        {
            "createdon",
            "createdby",
            "modifiedon",
            "modifiedby",
            "createdonbehalfby",
            "modifiedonbehalfby",
            "importsequencenumber"
        };

        /// <summary>
        /// Converts the entity to its early bound entity if it is not already such implemention. In that case it returns itself.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ent"></param>
        /// <returns></returns>
        public static T ToEarlyBoundEntity<T>(this T ent) where T : Microsoft.Xrm.Sdk.Entity
        {
            if (ent.GetType().BaseType == typeof(Microsoft.Xrm.Sdk.Entity))
            {
                return ent;
            }

            if (TO_ENT_GENS.ContainsKey(ent.LogicalName))
            {
                return TO_ENT_GENS[ent.LogicalName].Invoke(ent, new object[0]) as T;
            }

            if (!entittypes.ContainsKey(ent.LogicalName))
            {
                var enttype = Reflection.Types.Instance.EntityTypeFor(ent.LogicalName);
                if (enttype != null)
                {
                    entittypes[ent.LogicalName] = enttype;
                    return ToEarlyBoundEntity(ent);
                }
                throw new Exceptions.UnknownEntityTypeException(ent.LogicalName);
            }

            var type = entittypes[ent.LogicalName];
            TO_ENT_GENS[ent.LogicalName] = TO_ENTITY.MakeGenericMethod(type);

            return TO_ENT_GENS[ent.LogicalName].Invoke(ent, new object[0]) as T;
        }


        /// <summary>
        /// Returns the target filter attributes of the entity, when implementing interfaceType
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="entity"></param>
        /// <param name="interfaceType"></param>
        /// <returns></returns>
        public static string[] TargetFilterAttributesOf<T>(this T entity, Type interfaceType) where T : Microsoft.Xrm.Sdk.Entity
        {
            return typeof(T).TargetFilterAttributesOf(interfaceType);
        }


        /// <summary>
        /// Ths method resolved the attributes that are related to  specific interface, that inherits from Kipon.Xrm.ITarget
        /// </summary>
        /// <param name="entityType">The type of the entity</param>
        /// <param name="interfaceType">The interface implemented</param>
        /// <returns>List of fields that are part of target of the interface</returns>
        public static string[] TargetFilterAttributesOf(this Type entityType, Type interfaceType)
        {
            if (!typeof(Microsoft.Xrm.Sdk.Entity).IsAssignableFrom(entityType))
            {
                throw new InvalidPluginExecutionException("Only types that inherits from Microsoft.Xrm.Sdk.Entity can have class based TargetFilterAttribute.");
            }

            var key = $"{interfaceType.FullName}|{entityType.Name.ToLower()}";

            {
                if (targetattributes.TryGetValue(key, out string[] v))
                {
                    return v;
                }
            }

            lock (targetattributes)
            {
                if (targetattributes.TryGetValue(key, out string[] v))
                {
                    return v;
                }

                var type = entityType.GetTargetFilterAttribute(interfaceType);

                if (type == null)
                {
                    targetattributes[key] = null;
                    return null;
                }

                targetattributes[key] = type.Attributes;
                return targetattributes[key];
            }

        }

        /// <summary>
        /// Returns the property value of an entity if it is in there as an object, otherwise null
        /// </summary>
        /// <param name="entity">The entity</param>
        /// <param name="attribLogicalName">Name of attribute</param>
        /// <returns></returns>
        public static object GetSafeValue(this Microsoft.Xrm.Sdk.Entity entity, string attribLogicalName)
        {
            if (!entity.Attributes.ContainsKey(attribLogicalName))
            {
                return null;
            }
            return entity[attribLogicalName];
        }


        /// <summary>
        /// Return the target of the parent event. We can only find target for Create and Update parent events.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ctx"></param>
        /// <param name="message"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        public static T ParentTarget<T>(this Microsoft.Xrm.Sdk.IPluginExecutionContext ctx, string message, Guid id) where T : Microsoft.Xrm.Sdk.Entity, new()
        {
            if (message != "Create" && message != "Update")
            {
                throw new Exceptions.BaseException("ParentTarget method only support search for Create and Update request");
            }

            var parent = ctx.ParentContext;
            if (parent == null)
            {
                return null;
            }

            var proto = new T();

            if (parent.MessageName == message && parent.PrimaryEntityName == proto.LogicalName && parent.PrimaryEntityId == id)
            {
                var result = (Microsoft.Xrm.Sdk.Entity)parent.InputParameters["Target"];
                return result.ToEntity<T>();
            }

            if (ctx.MessageName == "ExecuteTransaction")
            {
                if (ctx.InputParameters.Contains("Requests"))
                {
                    var requests = ctx.InputParameters["Requests"] as Microsoft.Xrm.Sdk.OrganizationRequestCollection;
                    if (requests != null)
                    {
                        foreach (var r in requests)
                        {
                            switch (message)
                            {
                                case "Create":
                                    {
                                        if (r is Microsoft.Xrm.Sdk.Messages.CreateRequest c)
                                        {
                                            if (c.Target.LogicalName == proto.LogicalName && c.Target.Id == id)
                                            {
                                                return c.Target.ToEntity<T>();
                                            }
                                        }
                                        break;
                                    }
                                case "Update":
                                    {
                                        if (r is Microsoft.Xrm.Sdk.Messages.UpdateRequest c)
                                        {
                                            if (c.Target.LogicalName == proto.LogicalName && c.Target.Id == id)
                                            {
                                                return c.Target.ToEntity<T>();
                                            }
                                        }
                                        break;
                                    }
                            }
                        }
                    }
                }
            }
            return parent.ParentTarget<T>(message, id);
        }


        /// <summary>
        /// Find out if the ctx is OR has a parent contect that match the filter
        /// </summary>
        /// <param name="ctx">The context</param>
        /// <param name="message">The message, ex Create, Update ..., required</param>
        /// <param name="entityLogicalName">The logical name of the key, if null any, optional</param>
        /// <param name="id">The id of the entity expected to be a parent event, if null any, optional</param>
        /// <returns></returns>
        public static bool IsChildOf(this Microsoft.Xrm.Sdk.IPluginExecutionContext ctx, string message, string entityLogicalName = null, Guid? id = null)
        {
            if (ctx == null)
            {
                return false;
            }

            if (ctx.MessageName == message && (entityLogicalName == null || ctx.PrimaryEntityName == entityLogicalName) && (id == null || ctx.PrimaryEntityId == id))
            {
                return true;
            }

            if (ctx.MessageName == "ExecuteTransaction")
            {
                if (ctx.InputParameters.Contains("Requests"))
                {
                    var requests = ctx.InputParameters["Requests"] as Microsoft.Xrm.Sdk.OrganizationRequestCollection;
                    if (requests != null)
                    {
                        foreach (var r in requests)
                        {
                            switch (message)
                            {
                                case "Create":
                                    {
                                        if (r is Microsoft.Xrm.Sdk.Messages.CreateRequest c)
                                        {
                                            if ((entityLogicalName == null || c.Target.LogicalName == entityLogicalName) && (id == null || id == c.Target.Id)) return true;
                                        }
                                        break;
                                    }
                                case "Update":
                                    {
                                        if (r is Microsoft.Xrm.Sdk.Messages.UpdateRequest c)
                                        {
                                            if ((entityLogicalName == null || c.Target.LogicalName == entityLogicalName) && (id == null || id == c.Target.Id)) return true;
                                        }
                                        break;
                                    }
                                case "Delete":
                                    {
                                        if (r is Microsoft.Xrm.Sdk.Messages.DeleteRequest c)
                                        {
                                            if ((entityLogicalName == null || c.Target.LogicalName == entityLogicalName) && (id == null || id == c.Target.Id)) return true;
                                        }
                                        break;
                                    }
                            }

                            if (r.RequestName == message)
                            {
                                if (entityLogicalName == null && id == null)
                                {
                                    return true;
                                }

                                if (r.Parameters.ContainsKey("Target") && r.Parameters["Target"] is Microsoft.Xrm.Sdk.EntityReference targetid)
                                {
                                    if (targetid.LogicalName == entityLogicalName && (id == null || id == targetid.Id))
                                    {
                                        return true;
                                    }
                                }

                                if (r.Parameters.ContainsKey("Target") && r.Parameters["Target"] is Microsoft.Xrm.Sdk.Entity target)
                                {
                                    if (target.LogicalName == entityLogicalName && (id == null || id == target.Id))
                                    {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return ctx.ParentContext.IsChildOf(message, entityLogicalName, id);
        }

        /// <summary>
        /// Returns true if the attribute is part of the target payload of the request. It only make sense in Create, Update requests
        /// </summary>
        /// <param name="ctx">The plugin execution context</param>
        /// <param name="attributeName">The name of the attribute</param>
        /// <returns>True if context contains Target as an entity and the entity has the attribute set.</returns>
        public static bool AttributeChanged(this Microsoft.Xrm.Sdk.IPluginExecutionContext ctx, string attributeName)
        {
            if (ctx.InputParameters.Contains("Target") && ctx.InputParameters["Target"] is Microsoft.Xrm.Sdk.Entity e)
            {
                return e.Attributes.ContainsKey(attributeName.ToLower());
            }
            return false;
        }

        /// <summary>
        ///  Create an in memory instance as a clone of target.
        /// </summary>
        /// <typeparam name="T">Any strongly typed entity</typeparam>
        /// <param name="target">The entity instance</param>
        /// <param name="ommits">Fields that should be omitted in the copy</param>
        /// <returns></returns>
        public static T Clone<T>(this T target, params string[] ommits) where T : Microsoft.Xrm.Sdk.Entity, new()
        {
            var result = new T();

            var omitsLower = ommits?.Select(r => r.ToLower()).ToArray();
            var logicalname = target.LogicalName.ToLower();
            var keyname = $"{logicalname}id";

            switch (logicalname)
            {
                case "email":
                case "phonecall":
                case "appointment":
                case "task":
                case "campaignresponse":
                case "fax":
                case "letter":
                case "campaignactivity":
                case "socialactivity":
                case "opportunityclose":
                case "quoteclose":
                case "orderclose":
                case "incidentresolution":
                case "serviceappointment":
                case "recurringappointmentmaster":
                case "untrackedemail":
                case "bulkoperation":
                    {
                        keyname = "activityid";
                        break;
                    }
            }

            if (target.Attributes != null)
            {
                foreach (var k in target.Attributes.Keys)
                {
                    if (CLONE_EXCLUDE.Contains(k)) continue;
                    if (omitsLower != null && omitsLower.Contains(k)) continue;
                    if (k == keyname) continue;

                    result[k] = target[k];
                }
            }
            return result;
        }


        /// <summary>
        /// Convinient method to find the prevalue of something in the execution context.
        /// </summary>
        /// <typeparam name="T">The type T you expect to get back</typeparam>
        /// <param name="ctx">The Dynamics 365 execution context</param>
        /// <param name="entitypropertyname">The property name on the strongly typed entity of the flow</param>
        /// <returns></returns>
        public static T PreValueOf<T>(this IPluginExecutionContext ctx, string entitypropertyname)
        {
            System.Reflection.PropertyInfo prop = null;
            System.Type propertyType = null;

            string attributeName = null;
            if (ctx.PreEntityImages != null)
            {
                foreach (var pi in ctx.PreEntityImages.Values)
                {
                    if (prop == null)
                    {
                        var e = pi.ToEarlyBoundEntity();

                        prop = e.GetType().GetProperty(entitypropertyname);

                        if (prop == null)
                        {
                            throw new InvalidPluginExecutionException(string.Format(UNDEFINED_ATTRIBUTE_MESSAGE, pi.LogicalName, entitypropertyname));
                        }

                        var ca = (Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute)prop.GetCustomAttributes(typeof(Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute), false).FirstOrDefault();
                        if (ca == null)
                        {
                            throw new InvalidPluginExecutionException(string.Format(MISSING_DECORATION_ATTRIBUTE_MESSAGE, pi.LogicalName, entitypropertyname));
                        }

                        attributeName = ca.LogicalName;

                        propertyType = prop.PropertyType;

                        if (propertyType.IsGenericType)
                        {
                            var under = propertyType.GetGenericTypeDefinition();
                            if (under == typeof(Nullable<>))
                            {
                                propertyType = Nullable.GetUnderlyingType(propertyType);
                            }
                        }
                    }

                    if (pi.Attributes.Contains(attributeName))
                    {
                        var v = pi[attributeName];

                        if (v == null)
                        {
                            return default(T);
                        }

                        if (typeof(T).IsAssignableFrom(v.GetType()))
                        {
                            return (T)v;
                        }

                        if (propertyType.IsEnum && v is Microsoft.Xrm.Sdk.OptionSetValue osv)
                        {
                            foreach (T obj in Enum.GetValues(propertyType))
                            {
                                Enum test = Enum.Parse(propertyType, obj.ToString()) as Enum;
                                int x = Convert.ToInt32(test);
                                if (x == osv.Value)
                                {
                                    return (T)(object)test;
                                }
                            }
                            throw new InvalidPluginExecutionException($"On entity { pi.LogicalName } value { osv.Value } has not been mapped to Enum value of { propertyType.Name }");
                        }
                    }
                }
            }

            return default(T);
        }

        /// <summary>
        /// Return input parameters of the first parent object matching logicalname and message as T
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ctx"></param>
        /// <param name="logicalName">name of entity, null if unbound action</param>
        /// <param name="message">the message name, ex. update, create, or the action name</param>
        /// <returns></returns>
        public static T ParentInputParameters<T>(this IPluginExecutionContext ctx, string logicalName, string message)
        {
            var parent = ctx.ParentContext(logicalName, message);
            if (parent != null)
            {
                var type = typeof(T);
                var cType = type;
                #region T is an interface, and we need to find the one and only implementation
                if (type.IsInterface)
                {
                    cType = Types.Instance.TypeForInterface(type);
                }
                #endregion

                #region the T knows about IPluginExecutionContext and can extract values itself
                var con = cType.GetConstructor(new Type[] { typeof(IPluginExecutionContext) });
                if (con != null)
                {
                    return (T)con.Invoke(new object[] { parent });
                }
                #endregion

                #region parameter less constructor on type, simply assign value by naming convention
                con = cType.GetConstructor(new Type[0]);
                if (con != null)
                {
                    var result = con.Invoke(null);

                    foreach (var pam in parent.InputParameters)
                    {
                        if (pam.Value != null)
                        {
                            var name = pam.Key;
                            var prop = type.GetProperty(pam.Key);
                            if (prop != null && prop.CanWrite && prop.PropertyType.IsAssignableFrom(pam.Value.GetType()))
                            {
                                prop.SetValue(result, pam.Value);
                            }
                        }
                    }
                    return (T)result;
                }
                #endregion
            }
            return default(T);
        }

        /// <summary>
        /// Returns a single parameters as type T or default(T) if parent not found or parameter name not contained in parent context input parameters
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ctx"></param>
        /// <param name="logicalName"></param>
        /// <param name="message"></param>
        /// <param name="parameterName"></param>
        /// <returns></returns>
        public static T ParentInputParameter<T>(this Microsoft.Xrm.Sdk.IPluginExecutionContext ctx, string logicalName, string message, string parameterName)
        {
            var parent = ctx.ParentContext(logicalName, message);

            if (parent != null && parent.InputParameters != null && parent.InputParameters.Contains(parameterName))
            {
                return (T)parent.InputParameters[parameterName];
            }
            return default(T);
        }

        /// <summary>
        /// return parent context matching logicalname and message, null if no so parent exists in the pipeline
        /// </summary>
        /// <param name="ctx"></param>
        /// <param name="logicalName"></param>
        /// <param name="message"></param>
        /// <returns></returns>
        public static Microsoft.Xrm.Sdk.IPluginExecutionContext ParentContext(this Microsoft.Xrm.Sdk.IPluginExecutionContext ctx, string logicalName, string message)
        {
            if (ctx.ParentContext != null)
            {
                if (ctx.ParentContext.PrimaryEntityName == logicalName && ctx.ParentContext.MessageName == message)
                {
                    return ctx.ParentContext;
                }

                if (logicalName == null && ctx.ParentContext.PrimaryEntityName == null && ctx.ParentContext.MessageName == message)
                {
                    return ctx.ParentContext;
                }

                return ctx.ParentContext.ParentContext(logicalName, message);
            }
            return null;
        }

        private static TargetFilterAttribute GetTargetFilterAttribute(this Type entityType, Type interfaceType)
        {
            var properties = entityType.GetCustomAttributes(Reflection.TypeCache.Types.TargetFilterAttribute, false);

            if (properties != null && properties.Length > 0)
            {
                foreach (var prop in properties)
                {
                    var type = prop.GetType().GetProperty("Type")?.GetValue(prop) as Type;
                    var attr = prop.GetType().GetProperty("Attributes")?.GetValue(prop) as string[];
                    if (type != null && attr != null && type == interfaceType)
                    {
                        return new TargetFilterAttribute(type, attr);
                    }
                }
            }
            return null;
        }

        private class TargetFilterAttribute
        {
            internal TargetFilterAttribute(Type type, string[] attributes)
            {
                this.Type = type;
                this.Attributes = attributes.Select(r => r.ToLower()).ToArray();
            }

            internal Type Type { get; private set; }
            internal string[] Attributes { get; private set; }
        }

    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Extensions\Strings\StringMethods.cs
namespace Kipon.Tools.Xrm.Extensions.Strings
{
    using System.Linq;
    public static class StringMethods
    {
        public static string FirstToUpper(this string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return value;
            }

            return value.First().ToString().ToUpper() + value.Substring(1).ToLower();
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Extensions\TypeConverters\TypeConvertersMethods.cs
namespace Kipon.Tools.Xrm.Extensions.TypeConverters
{
    using System;

    public static class TypeConvertersMethods
    {
        public static Guid ToGuid(this int v1, params int[] others)
        {
            if (v1 > 99999999) throw new ArgumentException("Larges value for v1 is 99999999");
            if (others != null && others.Length >= 1 && others[0] > 9999) throw new ArgumentException("Larges value for v2 is 9999");
            if (others != null && others.Length >= 2 && others[1] > 9999) throw new ArgumentException("Larges value for v3 is 9999");
            if (others != null && others.Length >= 3 && others[2] > 9999) throw new ArgumentException("Larges value for v4 is 9999");

            var result = v1.ToString().PadLeft(8, '0');
            result += "-" + others != null && others.Length >= 1 ? others[0].ToString().PadLeft(4, '0') : "0000";
            result += "-" + others != null && others.Length >= 2 ? others[1].ToString().PadLeft(4, '0') : "0000";
            result += "-" + others != null && others.Length >= 3 ? others[2].ToString().PadLeft(4, '0') : "0000";
            result += "-" + others != null && others.Length == 4 ? others[3].ToString().PadLeft(12, '0') : "000000000000";

            return new Guid(result);
        }

        public static bool IsSame(this object from, object other)
        {
            if (from == null && other == null) return true;
            if (from != null && other == null) return false;
            if (from == null && other != null) return false;

            {
                if (from is Microsoft.Xrm.Sdk.Money f && other is Microsoft.Xrm.Sdk.Money t)
                {
                    return f.Value == t.Value;
                }
            }

            {
                if (from is Microsoft.Xrm.Sdk.Money f && other is decimal t)
                {
                    return f.Value == t;
                }
            }

            {
                if (from is decimal f && other is Microsoft.Xrm.Sdk.Money t)
                {
                    return f == t.Value;
                }
            }

            {
                if (from is Microsoft.Xrm.Sdk.OptionSetValue f && other is Microsoft.Xrm.Sdk.OptionSetValue t)
                {
                    return f.Value == t.Value;
                }
            }

            {
                if (from is Microsoft.Xrm.Sdk.OptionSetValue f && other is int t)
                {
                    return f.Value == t;
                }
            }

            {
                if (from is int f && other is Microsoft.Xrm.Sdk.OptionSetValue t)
                {
                    return f == t.Value;
                }
            }

            {
                if (from is Microsoft.Xrm.Sdk.EntityReference f && other is Microsoft.Xrm.Sdk.EntityReference t)
                {
                    return f.LogicalName == t.LogicalName && f.Id == t.Id;
                }
            }

            {
                if (from is Microsoft.Xrm.Sdk.EntityReference f && other is Guid t)
                {
                    return f.Id == t;
                }
            }

            {
                if (from is Guid f && other is Microsoft.Xrm.Sdk.EntityReference t)
                {
                    return f == t.Id;
                }
            }


            {
                if (from is decimal f && other is decimal t)
                {
                    return f == t;
                }
            }

            {
                if (from is string f && other is string t)
                {
                    return f == t;
                }
            }

            {
                if (from is int f && other is int t)
                {
                    return f == t;
                }
            }

            {
                if (from is long f && other is long t)
                {
                    return f == t;
                }
            }

            {

                if (from is double f && other is double t)
                {
                    return f == t;
                }
            }

            {
                if (from is float f && other is float t)
                {
                    return f == t;
                }
            }

            {
                if (from is bool f && other is bool t)
                {
                    return f == t;
                }
            }

            return from.Equals(other);
        }

    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Reflection\CommonProperty.cs
namespace Kipon.Tools.Xrm.Reflection
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public class CommonProperty
    {

        public class Cache
        {
            private readonly Dictionary<Type, CommonProperty[]> cache = new Dictionary<Type, CommonProperty[]>();
            private readonly object locks = new object();
            private readonly Types Types;

            public Cache(System.Reflection.Assembly assm)
            { 
                this.Types = Types.Instance;
            }

            public CommonProperty[] ForType(Type interfaceType, Type entityType)
            {
                if (cache.ContainsKey(interfaceType))
                {
                    return cache[interfaceType];
                }

                lock (locks)
                {
                    if (cache.ContainsKey(interfaceType))
                    {
                        return cache[interfaceType];
                    }

                    var interfaceProperties = interfaceType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                    var instanceProperties = entityType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);

                    var result = new List<CommonProperty>();

                    foreach (var interfaceProp in interfaceProperties)
                    {
                        var instanceProp = (from i in instanceProperties where i.Name == interfaceProp.Name select i).SingleOrDefault();
                        if (instanceProp != null)
                        {
                            var customProp = (Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute)instanceProp.GetCustomAttributes(typeof(Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute), false).FirstOrDefault();
                            if (customProp != null)
                            {
                                var attr = new CommonProperty { LogicalName = customProp.LogicalName };
                                attr.Required = interfaceProp.GetCustomAttributes(Types.RequiredAttribute, false).Any();

                                result.Add(attr);
                            }
                        }
                    }
                    cache[interfaceType] = result.ToArray();
                    return cache[interfaceType];
                }
            }

        }

        private static readonly Dictionary<CommonProperty.Key, CommonProperty[]> cache = new Dictionary<CommonProperty.Key, CommonProperty[]>();

        private static Types Types;

        static CommonProperty()
        {
            CommonProperty.Types = Types.Instance;
        }

        public static CommonProperty[] ForType(Type interfaceType, Type entityType)
        {
            var key = new CommonProperty.Key() { FromType = interfaceType, ToType = entityType };
            if (cache.ContainsKey(key))
            {
                return cache[key];
            }

            var interfaceProperties = interfaceType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
            var instanceProperties = entityType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);

            var result = new List<CommonProperty>();

            foreach (var interfaceProp in interfaceProperties)
            {
                if (interfaceProp.GetGetMethod() == null)
                {
                    continue;
                }

                if (interfaceProp.Name == nameof(Microsoft.Xrm.Sdk.Entity.Id))
                {
                    continue;
                }

                if (interfaceProp.Name == nameof(Microsoft.Xrm.Sdk.Entity.LogicalName))
                {
                    continue;
                }

                var instanceProp = (from i in instanceProperties where i.Name == interfaceProp.Name select i).SingleOrDefault();
                if (instanceProp != null)
                {
                    var customProp = (Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute)instanceProp.GetCustomAttributes(typeof(Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute), false).FirstOrDefault();
                    if (customProp != null)
                    {
                        var attr = new CommonProperty { LogicalName = customProp.LogicalName };
                        attr.Required = interfaceProp.GetCustomAttributes(Types.RequiredAttribute, false).Any();
                        attr.TargetFilter = interfaceProp.GetCustomAttributes(Types.TargetFilterAttribute, false).Any();

                        result.Add(attr);
                    }
                }
            }

            if (Types.ITarget.IsAssignableFrom(interfaceType))
            {
                var attributes = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.TargetFilterAttributesOf(entityType, interfaceType);
                if (attributes != null && attributes.Length > 0)
                {
                    foreach (var name in attributes)
                    {
                        var attr = result.Where(e => e.LogicalName == name).SingleOrDefault();
                        if (attr == null)
                        {
                            attr = new CommonProperty { LogicalName = name };
                            attr.Required = false;
                            attr.TargetFilter = true;

                            result.Add(attr);
                        }
                    }
                }
            }

            cache[key] = result.ToArray();
            return cache[key];
        }

        public string LogicalName { get; private set; }
        public bool Required { get; private set; }
        public bool TargetFilter { get; private set; }

        private class Key
        {
            internal Type FromType { get; set; }
            internal Type ToType { get; set; }

            public override bool Equals(object obj)
            {
                var other = obj as Key;

                if (other != null)
                {
                    return this.FromType == other.FromType && this.ToType == other.ToType;
                }
                return false;
            }

            public override int GetHashCode()
            {
                unchecked // Overflow is fine, just wrap
                {
                    int hash = 17;
                    // Suitable nullity checks etc, of course :)
                    hash = hash * 23 + FromType.GetHashCode();
                    hash = hash * 23 + ToType.GetHashCode();
                    return hash;
                }
            }
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Reflection\Output.cs
namespace Kipon.Tools.Xrm.Reflection
{
    public class Output
    {
        public string LogicalName { get; set; }
        public bool Requred { get; set; }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Reflection\PluginMethod.cs
namespace Kipon.Tools.Xrm.Reflection
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using Microsoft.Xrm.Sdk;

    public class PluginMethod
    {
        public class Cache
        {
            private Types Types;
            private readonly Dictionary<string, PluginMethod[]> cache = new Dictionary<string, PluginMethod[]>();

            private static readonly object locks = new object();

            private static readonly string[] IGNORE_METHODS = new string[]
            {
                nameof(BasePlugin.Equals),
                nameof(BasePlugin.Execute),
                nameof(BasePlugin.GetHashCode),
                nameof(BasePlugin.GetType),
                nameof(BasePlugin.PluginMethodCache),
                nameof(BasePlugin.ReferenceEquals),
                nameof(BasePlugin.SecureConfig),
                nameof(BasePlugin.ToString),
                nameof(BasePlugin.UnsecureConfig)
            };

            public Cache(System.Reflection.Assembly assm)
            {
                this.Types = Types.Instance;
                this.Types.SetAssembly(assm);
            }

            public PluginMethod[] ForPlugin(Type type, int stage, string message, string primaryEntityName, bool isAsync, bool throwIfEmpty = true)
            {
                var key = type.FullName + "|" + stage + "|" + message + "|" + primaryEntityName + "|" + isAsync.ToString();

                if (cache.ContainsKey(key))
                {
                    return cache[key];
                }

                lock (locks)
                {
                    if (cache.ContainsKey(key))
                    {
                        return cache[key];
                    }

                    var lookFor = $"On{stage.ToStage()}{message}{(isAsync ? "Async" : "")}";
                    var methods = type.GetMethods(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);

                    methods = (from m in methods where !m.Name.StartsWith("get_") && !IGNORE_METHODS.Contains(m.Name) select m).ToArray();

                    #region special handling of virtual entity plugin, that is the only thing than can end up calling in stage 30
                    if (stage == 30)
                    {
                        methods = methods.Where(r => r.Name == $"On{message}").ToArray();

                        MethodInfo fallback = null;
                        MethodInfo match = null;

                        foreach (var m in methods)
                        {
                            var attr = m.GetCustomAttributes(Types.LogicalNameAttribute).FirstOrDefault();
                            if (attr == null && fallback == null)
                            {
                                fallback = m;
                                continue;
                            }
                            if (attr == null && fallback != null)
                            {
                                throw new InvalidPluginExecutionException($"Virtaul entity plugin can only have a single method On{message} without explcit LogicalName attribute");
                            }

                            var logicalname = (string)attr.GetType().GetProperty("Value").GetValue(attr);
                            if (logicalname == primaryEntityName)
                            {
                                if (match == null)
                                {
                                    match = m;
                                    continue;
                                }

                                if (match != null)
                                {
                                    throw new InvalidPluginExecutionException($"There is more than one method On{message} that match logical name {primaryEntityName}. That is not allowed.");
                                }
                            }
                        }

                        if (match != null)
                        {
                            fallback = match;
                        }

                        if (fallback == null)
                        {
                            throw new InvalidPluginExecutionException($"Virtual Entity plugin must have a method called On{message}.");
                        }

                        var next = CreateFrom(fallback, null);

                        cache[key] = new[] { next };
                        return cache[key];
                    }
                    #endregion

                    var stepStage = stage == 40 && isAsync ? 41 : stage;
                    List<PluginMethod> results = new List<PluginMethod>();

                    foreach (var method in methods)
                    {
                        #region filter on logicalname attribute on method
                        if (primaryEntityName != null)
                        {
                            var logAttrs = method.GetCustomAttributes(Types.LogicalNameAttribute, false).ToArray();
                            if (logAttrs != null && logAttrs.Length > 0)
                            {
                                var foundLogicalName = false;
                                foreach (var logAttr in logAttrs)
                                {
                                    var name = (string)logAttr.GetType().GetProperty("Value").GetGetMethod().Invoke(logAttr, null);
                                    if (name == primaryEntityName)
                                    {
                                        foundLogicalName = true;
                                        break;
                                    }
                                }

                                if (!foundLogicalName)
                                {
                                    continue;
                                }
                            }
                        }
                        #endregion

                        #region explicit step decoration mathing
                        var cas = method.GetCustomAttributes(Types.StepAttribute, false);
                        var found = false;
                        foreach (var ca in cas)
                        {
                            var at = ca.GetType();
                            var _stage = (int)at.GetProperty("Stage").GetValue(ca);
                            var _message = at.GetProperty("Message").GetValue(ca).ToString();
                            var _primaryEntityName = (string)at.GetProperty("PrimaryEntityName").GetValue(ca);
                            var _isAsync = (bool)at.GetProperty("IsAsync").GetValue(ca);


                            if (_stage == stepStage && _message == message && _primaryEntityName == primaryEntityName && _isAsync == isAsync)
                            {
                                var next = CreateFrom(method, primaryEntityName);
                                AddIfConsistent(type, method, results, next, message, stage);
                                found = true;
                                break;
                            }
                        }

                        if (found)
                        {
                            continue;
                        }

                        if (cas.Length > 0)
                        {
                            continue;
                        }
                        #endregion

                        #region handling match on parameter of type ITarget, only continue and return this method, if the current primaryEntity actual implements the ITarget inherited interface
                        if (!string.IsNullOrEmpty(primaryEntityName))
                        {
                            var parameters = method.GetParameters();

                            if (parameters != null && parameters.Length > 0)
                            {
                                var itargetParameter = method.GetParameters().Where(p => Types.ITarget.IsAssignableFrom(p.ParameterType)).FirstOrDefault();
                                if (itargetParameter != null)
                                {
                                    var entity = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(new Microsoft.Xrm.Sdk.Entity(primaryEntityName));
                                    if (!itargetParameter.ParameterType.IsAssignableFrom(entity.GetType()))
                                    {
                                        continue;
                                    }
                                }
                            }
                        }
                        #endregion

                        #region find by naming convention
                        if (method.Name == lookFor)
                        {
                            var next = CreateFrom(method, primaryEntityName);

                            if (primaryEntityName == null)
                            {
                                AddIfConsistent(type, method, results, next, message, stage);
                                found = true;
                                continue;
                            }

                            var notrelevant = (from n in next.Parameters
                                               where n.LogicalName != null
                                                 && n.LogicalName != primaryEntityName
                                                 && n.IsGenericEntityInterface == false
                                               select n).Any();

                            if (notrelevant)
                            {
                                // at least on parameter is explicity something else than the current logical name
                                // so it is not relevant.
                                continue;
                            }

                            var logicalnames = (from l in next.Parameters
                                                where l.LogicalName != null
                                                  && l.IsGenericEntityInterface == false
                                                select l.LogicalName).Distinct().ToArray();

                            if (logicalnames.Length > 1)
                            {
                                throw new Exceptions.MultipleLogicalNamesException(type, method, logicalnames);
                            }

                            var logicalNames = (from n in next.Parameters where n.LogicalName != null select n.LogicalName).Distinct().ToArray();

                            if (logicalNames.Length == 1)
                            {
                                if (logicalNames[0] == primaryEntityName)
                                {
                                    AddIfConsistent(type, method, results, next, message, stage);
                                    found = true;
                                }
                                continue;
                            }

                            {
                                var logicalNameAttrs = method.GetCustomAttributes(Types.LogicalNameAttribute, false).ToArray();
                                foreach (var attr in logicalNameAttrs)
                                {
                                    var name = (string)attr.GetType().GetProperty("Value").GetValue(attr);
                                    if (name == primaryEntityName)
                                    {
                                        AddIfConsistent(type, method, results, next, message, stage);
                                        found = true;
                                        break;
                                    }
                                }

                                if (logicalNameAttrs.Length > 0)
                                {
                                    continue;
                                }
                            }

                            if (next.HasTargetPreOrPost() || next.HasTargetReference())
                            {
                                var logicalNamesAttrs = method.GetCustomAttributes(Types.LogicalNameAttribute, false).ToArray();
                                foreach (var attr in logicalNamesAttrs)
                                {
                                    var v = (string)attr.GetType().GetProperty("primaryEntityName").GetValue(attr);
                                    if (v == primaryEntityName)
                                    {
                                        found = true;
                                        break;
                                    }
                                }

                                if (found)
                                {
                                    AddIfConsistent(type, method, results, next, message, stage);
                                    continue;
                                }
                            }
                            else
                            {
                                // TO-DO: complete the list of messages not related to a specific entity.
                                if (!IsKnownMessage(message))
                                {
                                    throw new NotImplementedException($"handling method not attached to a logicalname is not supported yet { message }.");
                                }
                            }
                        }
                        #endregion
                    }

                    if (results.Count == 0 && throwIfEmpty)
                    {
                        throw new Exceptions.UnresolvablePluginMethodException(type);
                    }

                    cache[key] = results.OrderBy(r => r.Sort).ToArray();
                    return cache[key];
                }
            }

            private bool IsKnownMessage(string message)
            {
                switch (message)
                {
                    case "RemoveMember": return true;
                    case "QualifyLead": return true;
                }

                if (!message.StartsWith("_") && message.Contains("_")) return true;


                return false;
            }

            private void AddIfConsistent(Type type, System.Reflection.MethodInfo method, List<PluginMethod> results, PluginMethod result, string message, int stage)
            {
                #region validate pre and post image consistancy
                switch (stage)
                {
                    case 10:
                    case 20:
                        /* pre image pre event */
                        if (result.HasPreimageThatIsNotMergedImage() && message == "Create")
                        {
                            throw new Exceptions.UnavailableImageException(type, method, "Preimage", stage, message);
                        }
                        /* post image pre event */
                        if (result.HasPostimage())
                        {
                            throw new Exceptions.UnavailableImageException(type, method, "Postimage", stage, message);
                        }
                        break;
                    case 40:
                    case 41:
                        if (result.HasPostimage() && message == "Delete")
                        {
                            throw new Exceptions.UnavailableImageException(type, method, "Postimage", stage, message);
                        }
                        break;
                }
                #endregion

                #region validate target consistancy
                if (result.HasTargetBesideReference() && message == "Delete")
                {
                    throw new Exceptions.UnavailableImageException(type, method, "Target", stage, message);
                }

                if (result.HasTargetReference())
                {
                    var inError = true;
                    if (message == "Delete")
                    {
                        // delete always provides an entity reference as target, everything is good
                        inError = false;
                    }

                    var mess = message.Split('_');
                    if (mess.Length >= 2)
                    {
                        // this looks a lot like a custom action, it has the pattern prefix_name, bounded actions will also provide an entity reference, so we are good
                        inError = false;
                    }

                    // ADD other conditions where target is relevant, ex associate

                    if (inError)
                    {
                        throw new Exceptions.UnavailableImageException(type, method, "Target", stage, message);
                    }
                }
                #endregion

                results.Add(result);

                if (result.method.ReturnType != null)
                {
                    var outputProperties = result.method.ReturnType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                    if (outputProperties != null && outputProperties.Length > 0)
                    {
                        var output = new Dictionary<System.Reflection.PropertyInfo, Output>();
                        foreach (var p in outputProperties)
                        {
                            var outputAttr = p.GetCustomAttribute(Types.OutputAttribute);
                            if (outputAttr != null)
                            {
                                var name = (string)outputAttr.GetType().GetProperty("LogicalName").GetValue(outputAttr);
                                var req = (bool)outputAttr.GetType().GetProperty("Required").GetValue(outputAttr);
                                output.Add(p, new Output { LogicalName = name, Requred = req });
                            }
                        }
                        if (output.Count > 0)
                        {
                            result.OutputProperties = output;
                        }
                    }
                }
            }

            private PluginMethod CreateFrom(System.Reflection.MethodInfo method, string logicalname)
            {
                var result = new PluginMethod();
                result.Name = method.Name;
                result.method = method;
                var parameters = method.GetParameters().ToArray();

                result.Parameters = new TypeCache[parameters.Length];
                var ix = 0;
                foreach (var parameter in parameters)
                {
                    result.Parameters[ix] = TypeCache.ForParameter(parameter, logicalname);
                    ix++;
                }

                var sortAttr = method.GetCustomAttributes(Types.SortAttribute, false).SingleOrDefault();
                if (sortAttr != null)
                {
                    result.Sort = (int)sortAttr.GetType().GetProperty("Value").GetValue(sortAttr);
                }
                else
                {
                    result.Sort = 1;
                }
                return result;
            }

        }

        private PluginMethod()
        {
        }

        public static string ImageSuffixFor(int pre1post2, int stage, bool async)
        {
            var first = "Preimage";
            if (pre1post2 == 2)
            {
                first = "Postimage";
            }
            switch (stage)
            {
                case 10: return $"{first}Validate";
                case 20: return $"{first}Pre";
                case 40:
                    {
                        if (async) return $"{first}PostAsync";
                        return $"{first}Post";
                    }
            }
            throw new ArgumentException($"{nameof(stage)} can be 10, 20 or 40");
        }

        private System.Reflection.MethodInfo method;
        public int Sort { get; set; }
        public string Name { get; private set; }
        public TypeCache[] Parameters { get; private set; }

        public Dictionary<System.Reflection.PropertyInfo, Output> OutputProperties;

        #region target filter attributes
        private bool? _filterAllProperties;
        public bool FilterAllProperties
        {
            get
            {
                if (_filterAllProperties == null)
                {
                    _filterAllProperties = this.Parameters != null && this.Parameters.Where(r => r.IsTarget && r.AllProperties).Any();
                }
                return _filterAllProperties.Value;
            }
        }

        private CommonProperty[] _filteredProperties;
        public CommonProperty[] FilteredProperties
        {
            get
            {
                if (_filteredProperties == null)
                {
                    if (Parameters != null)
                    {
                        var result = new List<CommonProperty>();
                        foreach (var p in Parameters)
                        {
                            if (p.IsTarget && p.FilteredProperties != null && p.FilteredProperties.Length > 0)
                            {
                                result.AddRange(p.FilteredProperties);
                            }

                            if (p.IsPreimage && p.TargetFilterProperties.Length > 0)
                            {
                                result.AddRange(p.TargetFilterProperties);
                            }

                            if (p.IsPostimage && p.TargetFilterProperties.Length > 0)
                            {
                                result.AddRange(p.TargetFilterProperties);
                            }

                            if (p.IsMergedimage && p.TargetFilterProperties.Length > 0)
                            {
                                result.AddRange(p.TargetFilterProperties);
                            }

                        }
                        _filteredProperties = result.ToArray();
                    } else
                    {
                        _filteredProperties = new CommonProperty[0];
                    }
                }
                return _filteredProperties;
            }
        }
        #endregion

        #region preimage attributes
        private bool? _needPreimage;
        public bool NeedPreimage
        {
            get
            {
                if (this._needPreimage == null)
                {
                    this._needPreimage = this.Parameters != null && this.Parameters.Where(r => r.IsPreimage || r.IsMergedimage).Any();
                }
                return this._needPreimage.Value;
            }
        }

        private bool? _allPreimageProperties;
        public bool AllPreimageProperties
        {
            get
            {
                if (_allPreimageProperties == null)
                {
                    _allPreimageProperties = this.Parameters != null && this.Parameters.Where(r => (r.IsPreimage || r.IsMergedimage) && r.AllProperties).Any();
                }
                return _allPreimageProperties.Value;
            }
        }

        private CommonProperty[] _preimageProperties;
        public CommonProperty[] PreimageProperties
        {
            get
            {
                if (_preimageProperties == null)
                {
                    if (this.Parameters != null)
                    {
                        var result = new List<CommonProperty>();
                        foreach (var p in Parameters)
                        {
                            if ((p.IsPreimage || p.IsMergedimage) && p.FilteredProperties != null && p.FilteredProperties.Length > 0)
                            {
                                result.AddRange(p.FilteredProperties);
                            }
                        }
                        _preimageProperties = result.ToArray();
                    }
                    else
                    {
                        this._preimageProperties = new CommonProperty[0];
                    }
                }
                return _preimageProperties;
            }
        }
        #endregion

        #region postimage attributes
        private bool? _needPostimage;
        public bool NeedPostimage
        {
            get
            {
                if (this._needPostimage == null)
                {
                    this._needPostimage = this.Parameters != null && this.Parameters.Where(r => r.IsPostimage).Any();
                }
                return this._needPostimage.Value;
            }
        }

        private bool? _allPostimageProperties;
        public bool AllPostimageProperties
        {
            get
            {
                if (this._allPostimageProperties == null)
                {
                    this._allPostimageProperties = this.Parameters != null && this.Parameters.Where(r => r.IsPostimage && r.AllProperties).Any();
                }
                return this._allPostimageProperties.Value;
            }
        }

        private CommonProperty[] _postimageProperties;
        public CommonProperty[] PostimageProperties
        {
            get
            {
                if (this._postimageProperties == null)
                {
                    if (this.Parameters != null)
                    {
                        var result = new List<CommonProperty>();
                        foreach (var p in this.Parameters)
                        {
                            if (p.IsPostimage && p.FilteredProperties != null && p.FilteredProperties.Length > 0)
                            {
                                result.AddRange(p.FilteredProperties);
                            }
                        }
                        this._postimageProperties = result.ToArray();
                    }
                    else
                    {
                        this._postimageProperties = new CommonProperty[0];
                    }
                }
                return this._postimageProperties;
            }
        }
        #endregion

        private bool? _hasRequredProperties = null;
        public bool HasRequiredProperties
        {
            get
            {
                if (this._hasRequredProperties == null)
                {
                    this._hasRequredProperties = (from f in this.FilteredProperties where f.Required == true select f).Any();
                }
                return this._hasRequredProperties.Value;
            }
        }

        public bool HasPreimage()
        {
            return this.Parameters != null && (this.Parameters.Where(r => r.IsPreimage || r.IsMergedimage)).Any();
        }

        public bool HasPreimageThatIsNotMergedImage()
        {
            return this.Parameters != null && (this.Parameters.Where(r => r.IsPreimage)).Any();
        }

        public object Invoke(object instance, object[] args)
        {
            return this.method.Invoke(instance, args);
        }

        public bool HasPostimage()
        {
            return this.Parameters != null && (this.Parameters.Where(r => r.IsPostimage)).Any();
        }

        public bool HasTargetBesideReference()
        {
            return this.Parameters != null && (this.Parameters.Where(r => r.IsTarget && r.IsReference == false)).Any();
        }


        public bool HasTarget()
        {
            return this.Parameters != null && (this.Parameters.Where(r => r.IsTarget)).Any();
        }

        public bool HasTargetPreOrPost()
        {
            return this.Parameters != null && this.Parameters.Where(r => r.IsTarget || r.IsPreimage || r.IsMergedimage || r.IsPostimage).Any();
        }

        public bool HasTargetReference()
        {
            return this.Parameters != null && this.Parameters.Where(r => r.IsReference).Any();
        }

        public bool IsRelevant(Microsoft.Xrm.Sdk.Entity target)
        {
            if (this.FilterAllProperties)
            {
                return true;
            }

            if (this.FilteredProperties != null && this.FilteredProperties.Length > 0)
            {
                foreach (var f in this.FilteredProperties)
                {
                    if (target.Attributes.Keys.Contains(f.LogicalName))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    internal static class PluginMethodCacheLocalExtensions
    {
        public static string ToStage(this int value)
        {
            switch(value)
            {
                case 10: return "Validate";
                case 20: return "Pre";
                case 30: return ""; // virtual entity query request
                case 40: return "Post";
                default: throw new Microsoft.Xrm.Sdk.InvalidPluginExecutionException($"Unknown state {value}");
            }
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Reflection\ServiceCache.cs
namespace Kipon.Tools.Xrm.Reflection
{
    using Microsoft.Xrm.Sdk;
    using System;
    using System.Collections.Generic;
    public class ServiceCache: System.IDisposable
    {
        private readonly Dictionary<string, object> services = new Dictionary<string, object>();
        private readonly object locks = new object();

        public string UnsecureConfig { get; private set; }
        public string SecureConfig { get; private set; }

        private Guid systemuserid;

        private IPluginExecutionContext pluginExecutionContext;
        private IOrganizationServiceFactory organizationServiceFactory;

        public ServiceCache(IPluginExecutionContext pluginExecutionContext, IOrganizationServiceFactory organizationServiceFactory, ITracingService traceService, IPluginContext pluginContext, string config, string secureConfig)
        {
            this.UnsecureConfig = config;
            this.SecureConfig = secureConfig;
            this.pluginExecutionContext = pluginExecutionContext;
            this.organizationServiceFactory = organizationServiceFactory;
            this.services.Add(typeof(IPluginExecutionContext).FullName, pluginExecutionContext);
            this.services.Add(typeof(IOrganizationServiceFactory).FullName, organizationServiceFactory);
            this.services.Add(typeof(ITracingService).FullName, traceService);

            if (pluginContext != null)
            {
                this.services.Add(typeof(IPluginContext).FullName, pluginContext);
            } else
            {
                var type = (CrmEventType)Enum.Parse(typeof(CrmEventType), pluginExecutionContext.MessageName);
                var pContext = new Services.PluginContext(null, null, pluginExecutionContext, type, pluginExecutionContext.UserId);
                this.services.Add(typeof(IPluginContext).FullName, pContext);
            }
            this.systemuserid = pluginExecutionContext.UserId;
        }

        public object Resolve(TypeCache type)
        {
            return this.Resolve(type, null);
        }

        public object Resolve(TypeCache type, Microsoft.Xrm.Sdk.IOrganizationService orgService)
        {
            try
            {
                if (services.ContainsKey(type.ObjectInstanceKey))
                {
                    return services[type.ObjectInstanceKey];
                }

                lock (locks)
                {
                    if (services.ContainsKey(type.ObjectInstanceKey))
                    {
                        return services[type.ObjectInstanceKey];
                    }

                    if (type.FromType == typeof(Guid) && type.Name != null && type.Name.ToLower() == nameof(this.pluginExecutionContext.PrimaryEntityId).ToLower())
                    {
                        return this.pluginExecutionContext.PrimaryEntityId;
                    }

                    if (type.FromType == typeof(string) && type.Name != null && type.Name.ToLower() == nameof(this.pluginExecutionContext.PrimaryEntityName).ToLower())
                    {
                        return this.pluginExecutionContext.PrimaryEntityName;
                    }

                    if (type.FromType == typeof(string) && type.Name != null && type.Name.ToLower() == nameof(BasePlugin.UnsecureConfig).ToLower()) 
                    {
                        return this.UnsecureConfig;
                    }

                    if (type.FromType == typeof(string) && type.Name != null && type.Name.ToLower() == nameof(BasePlugin.SecureConfig).ToLower())
                    {
                        return this.SecureConfig;
                    }

                    if (type.FromType == typeof(Microsoft.Xrm.Sdk.Query.QueryExpression))
                    {
                        if (pluginExecutionContext.InputParameters.Contains("Query"))
                        {
                            var query = pluginExecutionContext.InputParameters["Query"];
                            if (query is Microsoft.Xrm.Sdk.Query.QueryExpression qe)
                            {
                                // no cache by design - need to be resolved on all request.
                                return qe;
                            }

                            if (query is Microsoft.Xrm.Sdk.Query.FetchExpression fe)
                            {
                                var resp = (Microsoft.Crm.Sdk.Messages.FetchXmlToQueryExpressionResponse)orgService.Execute(new Microsoft.Crm.Sdk.Messages.FetchXmlToQueryExpressionRequest
                                {
                                    FetchXml = fe.Query
                                });
                                return resp.Query;
                            }

                            throw new Exceptions.UnresolvedQueryParameter(type.Name);
                        }
                        else
                        {
                            throw new InvalidPluginExecutionException("QueryExpression can only be requested for RetrieveMultiple requests");
                        }
                    }

                    if (type.IsTarget && !type.IsReference)
                    {
                        var entity = (Microsoft.Xrm.Sdk.Entity)pluginExecutionContext.InputParameters["Target"];
                        services[type.ObjectInstanceKey] = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(entity);
                        return services[type.ObjectInstanceKey];
                    }

                    if (type.IsPreimage)
                    {
                        var imgName = PluginMethod.ImageSuffixFor(1, pluginExecutionContext.Stage, pluginExecutionContext.Mode == 1);
                        var entity = (Microsoft.Xrm.Sdk.Entity)pluginExecutionContext.PreEntityImages[imgName];
                        services[type.ObjectInstanceKey] = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(entity);
                        return services[type.ObjectInstanceKey];
                    }

                    if (type.IsPostimage)
                    {
                        var imgName = PluginMethod.ImageSuffixFor(2, pluginExecutionContext.Stage, pluginExecutionContext.Mode == 1);
                        var entity = (Microsoft.Xrm.Sdk.Entity)pluginExecutionContext.PostEntityImages[$"postimage{imgName}"];
                        services[type.ObjectInstanceKey] = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(entity);
                        return services[type.ObjectInstanceKey];
                    }

                    if (type.IsMergedimage)
                    {
                        var target = (Microsoft.Xrm.Sdk.Entity)pluginExecutionContext.InputParameters["Target"];
                        var merged = new Microsoft.Xrm.Sdk.Entity();
                        merged.Id = target.Id;
                        merged.LogicalName = target.LogicalName;

                        if (pluginExecutionContext.MessageName == "Create")
                        {
                            merged = target; 
                        } else
                        {
                            var imgName = PluginMethod.ImageSuffixFor(1, pluginExecutionContext.Stage, pluginExecutionContext.Mode == 1);
                            var pre = (Microsoft.Xrm.Sdk.Entity)pluginExecutionContext.PreEntityImages[imgName];

                            foreach (var attr in pre.Attributes.Keys)
                            {
                                merged[attr] = pre[attr];
                            }

                            foreach (var attr in target.Attributes.Keys)
                            {
                                merged[attr] = target[attr];
                            }
                        }

                        services[type.ObjectInstanceKey] = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(merged);
                        return services[type.ObjectInstanceKey];
                    }

                    if (type.IsReference)
                    {
                        var target = (Microsoft.Xrm.Sdk.EntityReference)pluginExecutionContext.InputParameters["Target"];
                        if (type.Constructor != null)
                        {
                            services[type.ObjectInstanceKey] = type.Constructor.Invoke(new object[] { target });
                        }
                        else
                        {
                            services[type.ObjectInstanceKey] = target;
                        }
                        return services[type.ObjectInstanceKey];
                    }

                    if (type.FromType == typeof(Microsoft.Xrm.Sdk.IOrganizationService))
                    {
                        return this.GetOrganizationService(type.RequireAdminService);
                    }

                    if (type.IsQuery)
                    {
                        var uow = this.GetIUnitOfWork(type.RequireAdminService);
                        var queryProperty = type.RepositoryProperty;
                        var repository = queryProperty.GetValue(uow, new object[0]);
                        var queryMethod = type.QueryMethod;
                        return queryMethod.Invoke(repository, new object[0]);
                    }

                    if (type.FromType == typeof(Guid))
                    {
                        if (type.Name.ToLower() == "id")
                        {
                            return pluginExecutionContext.PrimaryEntityId;
                        }

                        if (type.Name.ToLower() == "listid")
                        {
                            return pluginExecutionContext.InputParameters["ListId"];
                        }

                        if (type.Name.ToLower() == "entityid")
                        {
                            return pluginExecutionContext.InputParameters["EntityId"];
                        }

                        throw new Exceptions.UnresolveableParameterException(type.FromType, type.Name);
                    }

                    return this.CreateServiceInstance(type);
                }
            }
            catch (System.Collections.Generic.KeyNotFoundException)
            {
                var typeName = (type?.FromType?.FullName) ?? "type was null";
                var key = type?.ObjectInstanceKey ?? "object instance key as null";
                throw new InvalidPluginExecutionException($"Unable to resolve service {typeName}, {key} or one of its dependencies.");
            }
        }

        private List<string> resolving = new List<string>();

        private IUnitOfWork GetIUnitOfWork(bool admin)
        {
            TypeCache tc = TypeCache.ForUow(admin);
            return (IUnitOfWork)this.CreateServiceInstance(tc);
        }

        private Microsoft.Xrm.Sdk.IOrganizationService GetOrganizationService(bool admin)
        {
            var objectInstanceKey = typeof(Microsoft.Xrm.Sdk.IOrganizationService).FullName;
            if (admin)
            {
                objectInstanceKey += ":admin";
            }
            if (services.ContainsKey(objectInstanceKey))
            {
                return (Microsoft.Xrm.Sdk.IOrganizationService)services[objectInstanceKey];
            }
            if (admin)
            {
                services[objectInstanceKey] = this.organizationServiceFactory.CreateOrganizationService(null);
            }
            else
            {
                services[objectInstanceKey] = this.organizationServiceFactory.CreateOrganizationService(this.systemuserid);
            }

            return (Microsoft.Xrm.Sdk.IOrganizationService)services[objectInstanceKey];
        }

        private object CreateServiceInstance(TypeCache type)
        {
            if (resolving.Contains(type.ObjectInstanceKey))
            {
                throw new Exceptions.CircularDependencyException(string.Join(">", resolving.ToArray()));
            }
            try
            {
                resolving.Add(type.ObjectInstanceKey);
                var argTypes = ServiceConstructorCache.ForConstructor(type.Constructor);
                var args = new object[argTypes != null ? argTypes.Length : 0];

                if (args.Length == 0)
                {
                    services[type.ObjectInstanceKey] = type.Constructor.Invoke(args);
                    return services[type.ObjectInstanceKey];
                }

                var ix = 0;
                foreach (var argType in argTypes)
                {
                    if (argType.FromType == typeof(string) && argType.Name != null && argType.Name.ToLower() == nameof(BasePlugin.UnsecureConfig).ToLower())
                    {
                        args[ix] = this.UnsecureConfig;
                        ix++;
                        continue;
                    }

                    if (argType.FromType == typeof(string) && argType.Name != null && argType.Name.ToLower() == nameof(BasePlugin.SecureConfig).ToLower())
                    {
                        args[ix] = this.SecureConfig;
                        ix++;
                        continue;
                    }

                    if (argType.FromType == typeof(Microsoft.Xrm.Sdk.IOrganizationService))
                    {
                        if (type.RequireAdminService)
                        {
                            var key = typeof(Microsoft.Xrm.Sdk.IOrganizationService).FullName + ":admin";
                            if (services.ContainsKey(key))
                            {
                                args[ix] = services[key];
                                ix++;
                                continue;
                            }
                            else
                            {
                                services[key] = this.organizationServiceFactory.CreateOrganizationService(null);
                                args[ix] = services[key];
                                ix++;
                                continue;
                            }
                        }
                        else
                        {
                            var key = typeof(Microsoft.Xrm.Sdk.IOrganizationService).FullName;
                            if (services.ContainsKey(key))
                            {
                                args[ix] = services[key];
                                ix++;
                                continue;
                            }
                            else
                            {
                                services[key] = this.organizationServiceFactory.CreateOrganizationService(this.systemuserid);
                                args[ix] = services[key];
                                ix++;
                                continue;
                            }
                        }
                    }

                    if (services.ContainsKey(argType.ObjectInstanceKey))
                    {
                        args[ix] = services[argType.ObjectInstanceKey];
                        ix++;
                        continue;
                    }

                    {
                        services[argType.ObjectInstanceKey] = this.CreateServiceInstance(argType);
                        args[ix] = services[argType.ObjectInstanceKey];
                        ix++;
                        continue;
                    }
                }
                return type.Constructor.Invoke(args);
            }
            finally
            {
                resolving.Remove(type.ObjectInstanceKey);
            }
        }

        public void OnStepFinalize()
        {
            if (this.services != null)
            {
                foreach (var s in this.services.Values)
                {
                    var asdispos = s as IService;
                    if (asdispos != null)
                    {
                        asdispos.OnStepFinalized();
                    }
                }
            }
        }

        public void Dispose()
        {
            if (this.services != null)
            {
                foreach (var s in this.services.Values)
                {
                    var asdispos = s as System.IDisposable;
                    if (asdispos != null)
                    {
                        asdispos.Dispose();
                    }
                }
                this.services.Clear();
            }
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Reflection\ServiceConstructorCache.cs
namespace Kipon.Tools.Xrm.Reflection
{
    using System.Collections.Generic;
    public class ServiceConstructorCache
    {
        private readonly static Dictionary<System.Reflection.ConstructorInfo, TypeCache[]> cache = new Dictionary<System.Reflection.ConstructorInfo, TypeCache[]>();

        private static readonly object locks = new object();

        public static TypeCache[] ForConstructor(System.Reflection.ConstructorInfo constructor)
        {
            if (cache.ContainsKey(constructor))
            {
                return cache[constructor];
            }

            lock (locks)
            {
                if (cache.ContainsKey(constructor))
                {
                    return cache[constructor];
                }

                var parameters = constructor.GetParameters();
                if (parameters == null || parameters.Length == 0)
                {
                    cache[constructor] = new TypeCache[0];
                    return cache[constructor];
                }

                var result = new TypeCache[parameters.Length];

                var ix = 0;
                foreach (var par in parameters)
                {
                    result[ix] = TypeCache.ForParameter(par, null);
                    if (result[ix].RequirePluginContext)
                    {
                        throw new Exceptions.InvalidConstructorServiceArgumentException(constructor, par);
                    }
                    ix++;
                }
                cache[constructor] = result;
                return result;
            }
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Reflection\TypeCache.cs
namespace Kipon.Tools.Xrm.Reflection
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Type cache is used to resolved types for each parameter in a context. 
    /// If the parameter is related to images (target, pre, post etc.), 
    /// The type is cached on the pointer to the parameter, so each parameter is only resolved 
    /// once in the system life-time.
    /// </summary>
    public class TypeCache
    {
        public static Types Types { get; set; }

        private static System.Reflection.ParameterInfo UOW;
        private static System.Reflection.ParameterInfo UOW_ADMIN;

        private static readonly object locks = new object();

        static TypeCache()
        {
            TypeCache.Types = Types.Instance;
            var method = typeof(TypeCache).GetMethod(nameof(TypeCache.DummyUOW), System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            var pms = method.GetParameters();
            UOW = pms[0];
            UOW_ADMIN = pms[1];
        }

        private static Dictionary<Key, TypeCache> resolvedTypes = new Dictionary<Key, TypeCache>();

        public static TypeCache ForParameter(System.Reflection.ParameterInfo parameter, string logicalname)
        {
            var key = new Key() { Parameter = parameter, LogicalName = logicalname };

            var type = parameter.ParameterType;

            if (resolvedTypes.ContainsKey(key))
            {
                return resolvedTypes[key];
            }

            lock (locks)
            {
                if (resolvedTypes.ContainsKey(key))
                {
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Guid))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(string))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(int))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(int?))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(decimal))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(decimal?))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(bool))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(bool?))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.EntityReference))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.OptionSetValue))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.Money))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type, Name = parameter.Name, IsInputParameter = true };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.IOrganizationService))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type };

                    resolvedTypes[key].RequireAdminService = parameter.GetCustomAttributes(Types.AdminAttribute, false).Any();
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.IOrganizationServiceFactory))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.IPluginExecutionContext))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.ITracingService))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == Types.IPluginContext)
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, ToType = type };
                    return resolvedTypes[key];
                }

                if (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.Query.QueryExpression))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, Name = parameter.Name, ToType = type };
                    return resolvedTypes[key];
                }

                if (parameter.Name.ToLower() == "datasource" && (parameter.ParameterType == typeof(Microsoft.Xrm.Sdk.Entity) || parameter.ParameterType.BaseType == typeof(Microsoft.Xrm.Sdk.Entity)))
                {
                    resolvedTypes[key] = new TypeCache { FromType = type, Name = parameter.Name, ToType = type };
                    return resolvedTypes[key];
                }

                #region not an abstract, and not an interface, the type can be used directly, see if the name indicates that it is target, preimage, mergedimage or postimage
                if (!type.IsInterface && !type.IsAbstract)
                {
                    var constructors = type.GetConstructors(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);

                    if (constructors != null && constructors.Length > 0)
                    {
                        var result = new TypeCache { FromType = type, ToType = type };
                        var isEntity = false;

                        #region see if we can resolve parameter to the target as an entity
                        if (parameter.MatchPattern(Types.TargetAttribute, "target") && type.BaseType == typeof(Microsoft.Xrm.Sdk.Entity))
                        {
                            isEntity = true;
                            result.IsTarget = true;
                        }
                        else
                        if (parameter.MatchPattern(Types.PreimageAttribute, "preimage") && type.BaseType == typeof(Microsoft.Xrm.Sdk.Entity))
                        {
                            isEntity = true;
                            result.IsPreimage = true;
                        }
                        else
                        if (parameter.MatchPattern(Types.MergedimageAttribute, "mergedimage") && type.BaseType == typeof(Microsoft.Xrm.Sdk.Entity))
                        {
                            isEntity = true;
                            result.IsMergedimage = true;
                        }
                        else
                        if (parameter.MatchPattern(Types.PostimageAttribute, "postimage") && type.BaseType == typeof(Microsoft.Xrm.Sdk.Entity))
                        {
                            isEntity = true;
                            result.IsPostimage = true;
                        }

                        if (isEntity)
                        {
                            var entity = (Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(type);
                            result.LogicalName = entity.LogicalName;
                            result.ResolveProperties();
                        }
                        #endregion

                        var isReference = false;

                        #region see if we can resolve parameter to the target as en entity reference
                        if (!isEntity && type.ExtendsGenericClassOf(Types.TargetReference))
                        {
                            isReference = true;
                            result.IsTarget = true;
                            result.IsReference = true;
                            result.ToType = type.BaseType.GetGenericArguments()[0];

                            var entity = (Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(result.ToType);
                            result.LogicalName = entity.LogicalName;
                            result.Constructor = type.GetConstructor(new Type[] { typeof(Microsoft.Xrm.Sdk.EntityReference) });
                        }

                        if (!isEntity && !isReference && type == typeof(Microsoft.Xrm.Sdk.EntityReference))
                        {
                            if (parameter.MatchPattern(Types.TargetAttribute, "target"))
                            {
                                isReference = true;
                                result.IsTarget = true;
                                result.IsReference = true;
                                result.ToType = type;
                                result.Constructor = null;
                            }
                        }
                        #endregion

                        if (!isEntity && !isReference)
                        {
                            result.Constructor = GetConstructor(type);
                            resolvedTypes[key] = result;
                        }
                        else
                        {
                            resolvedTypes[key] = result;
                        }
                        return result;
                    }
                }
                #endregion

                #region see if it is target, preimage post image or merged image interface
                if (type.IsInterface)
                {
                    Type toType = type.ImplementsGenericInterface(Types.Target);
                    if (toType != null)
                    {
                        var result = new TypeCache { FromType = type, ToType = toType, IsTarget = true };
                        var entity = (Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(result.ToType);
                        result.LogicalName = entity.LogicalName;
                        result.ResolveProperties();

                        if (ReturnIfOk(type, result))
                        {
                            resolvedTypes[key] = result;
                            return result;
                        }
                    }

                    toType = type.ImplementsGenericInterface(Types.Preimage);
                    if (toType != null)
                    {
                        var result = new TypeCache { FromType = type, ToType = toType, IsPreimage = true };
                        var entity = (Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(result.ToType);
                        result.LogicalName = entity.LogicalName;
                        result.ResolveProperties();
                        if (ReturnIfOk(type, result))
                        {
                            resolvedTypes[key] = result;
                            return resolvedTypes[key];
                        }
                    }

                    toType = type.ImplementsGenericInterface(Types.Mergedimage);
                    if (toType != null)
                    {
                        var result = new TypeCache { FromType = type, ToType = toType, IsMergedimage = true };
                        var entity = (Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(result.ToType);
                        result.LogicalName = entity.LogicalName;
                        result.ResolveProperties();
                        if (ReturnIfOk(type, result))
                        {
                            resolvedTypes[key] = result;
                            return resolvedTypes[key];
                        }
                    }

                    toType = type.ImplementsGenericInterface(Types.Postimage);
                    if (toType != null)
                    {
                        var result = new TypeCache { FromType = type, ToType = toType, IsPostimage = true };
                        var entity = (Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(result.ToType);
                        result.LogicalName = entity.LogicalName;
                        result.ResolveProperties();
                        if (ReturnIfOk(type, result))
                        {
                            resolvedTypes[key] = result;
                            return result;
                        }
                    }

                    if (type.IsITarget())
                    {
                        var entity = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(new Microsoft.Xrm.Sdk.Entity { LogicalName = key.LogicalName });
                        var entityType = entity.GetType();

                        if (type.IsAssignableFrom(entityType))
                        {
                            var result = new TypeCache { FromType = type, ToType = entityType, IsTarget = true };
                            result.LogicalName = entity.LogicalName;
                            result.ResolveProperties();

                            if (ReturnIfOk(type, result))
                            {
                                resolvedTypes[key] = result;
                                return result;
                            }
                        }
                    }
                }
                #endregion

                #region handle shared interface by naming convention or attribute decoration
                if (type.IsInterface && !string.IsNullOrEmpty(key.LogicalName))
                {
                    var isTarget = parameter.Name == "target";

                    if (!isTarget)
                    {
                        isTarget = parameter.GetCustomAttributes(Types.TargetAttribute, false).Any();
                    }

                    if (isTarget)
                    {
                        var entity = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(new Microsoft.Xrm.Sdk.Entity { LogicalName = key.LogicalName });

                        var result = new TypeCache { FromType = type, ToType = entity.GetType(), IsTarget = true };
                        result.LogicalName = key.LogicalName;
                        result.IsGenericEntityInterface = true;
                        result.ResolveProperties();
                        result.IsImplemenedByEntity = ReturnIfImplemented(type, result);
                        resolvedTypes[key] = result;
                        return result;
                    }
                }

                if (type.IsInterface && !string.IsNullOrEmpty(key.LogicalName))
                {
                    var isPreimage = parameter.Name == "preimage";

                    if (!isPreimage)
                    {
                        isPreimage = parameter.GetCustomAttributes(Types.PreimageAttribute, false).Any();
                    }

                    if (isPreimage)
                    {
                        var entity = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(new Microsoft.Xrm.Sdk.Entity { LogicalName = key.LogicalName });

                        var result = new TypeCache { FromType = type, ToType = entity.GetType(), IsPreimage = true };
                        result.LogicalName = key.LogicalName;
                        result.IsGenericEntityInterface = true;
                        result.ResolveProperties();
                        result.IsImplemenedByEntity = ReturnIfImplemented(type, result);
                        resolvedTypes[key] = result;
                        return result;
                    }
                }

                if (type.IsInterface && !string.IsNullOrEmpty(key.LogicalName))
                {
                    var isMergedimage = parameter.Name == "mergedimage";

                    if (!isMergedimage)
                    {
                        isMergedimage = parameter.GetCustomAttributes(Types.MergedimageAttribute, false).Any();
                    }

                    if (isMergedimage)
                    {
                        var entity = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(new Microsoft.Xrm.Sdk.Entity { LogicalName = key.LogicalName });

                        var result = new TypeCache { FromType = type, ToType = entity.GetType(), IsMergedimage = true };
                        result.LogicalName = key.LogicalName;
                        result.IsGenericEntityInterface = true;
                        result.ResolveProperties();
                        result.IsImplemenedByEntity = ReturnIfImplemented(type, result);
                        resolvedTypes[key] = result;
                        return result;
                    }
                }

                if (type.IsInterface && !string.IsNullOrEmpty(key.LogicalName))
                {
                    var isPostimage = parameter.Name == "postimage";

                    if (!isPostimage)
                    {
                        isPostimage = parameter.GetCustomAttributes(Types.PostimageAttribute, false).Any();
                    }

                    if (isPostimage)
                    {
                        var entity = Extensions.Sdk.KiponSdkGeneratedExtensionMethods.ToEarlyBoundEntity(new Microsoft.Xrm.Sdk.Entity { LogicalName = key.LogicalName });

                        var result = new TypeCache { FromType = type, ToType = entity.GetType(), IsPostimage = true };
                        result.LogicalName = key.LogicalName;
                        result.IsGenericEntityInterface = true;
                        result.ResolveProperties();
                        result.IsImplemenedByEntity = ReturnIfImplemented(type, result);
                    }
                }
                #endregion

                #region IQueryable
                if (type.IsInterface && type.IsGenericType && type.GenericTypeArguments.Length == 1 && type.GenericTypeArguments[0].BaseType != null && type.GenericTypeArguments[0].BaseType == typeof(Microsoft.Xrm.Sdk.Entity))
                {
                    var result = ForQuery(type);
                    if (result != null)
                    {
                        result.RequireAdminService = parameter.GetCustomAttributes(Types.AdminAttribute, false).Any();
                        return result;
                    }
                }
                #endregion

                #region find implementing interface
                if (type.IsInterface)
                {
                    var r1 = GetInterfaceImplementation(type);

                    var entityType = type.ImplementsGenericInterface(Types.ActionTarget);
                    string logialName = null;
                    bool isActionReference = false;

                    if (entityType != null)
                    {
                        logialName = ((Microsoft.Xrm.Sdk.Entity)Activator.CreateInstance(entityType)).LogicalName;
                        isActionReference = true;
                    }

                    var result = new TypeCache { FromType = type, ToType = r1, Constructor = GetConstructor(r1), LogicalName = logialName, IsActionReference = isActionReference };

                    resolvedTypes[key] = result;
                    return result;
                }
                #endregion

                #region find relevant abstract extension
                if (type.IsAbstract)
                {
                }
                #endregion

                throw new Exceptions.UnresolvableTypeException(type);
            }
        }

        public static TypeCache ForQuery(Type type)
        {
            var genericQueryable = typeof(System.Linq.IQueryable<>);
            var queryType = genericQueryable.MakeGenericType(type.GenericTypeArguments[0]);
            if (type == queryType)
            {
                var result = new TypeCache { FromType = type, ToType = queryType, IsQuery = true };
                return result;
            }
            return null;
        }

        public static TypeCache ForUow(bool admin)
        {
            var pi = admin ? UOW_ADMIN : UOW;

            var key = new Key { Parameter = pi };
            if (resolvedTypes.ContainsKey(key))
            {
                return resolvedTypes[key];
            }

            var fromType = admin ? Types.IAdminUnitOfWork : Types.IUnitOfWork;
            var r1 = GetInterfaceImplementation(fromType);
            var result = new TypeCache { FromType = fromType, ToType = r1, Constructor = GetConstructor(r1), RequireAdminService = admin };
            resolvedTypes[key] = result;
            return result;
        }

        private void DummyUOW(object uow, object adminUOW)
        {
        }

        #region private static helpers
        private static Type GetInterfaceImplementation(Type type)
        {
            var allTypes = Types.Assembly.GetTypes();
            var candidates = new List<Type>();

            foreach (var t in allTypes)
            {
                if (!t.IsInterface && !t.IsAbstract && type.IsAssignableFrom(t))
                {
                    var cons = t.GetConstructors(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                    if (cons.Length > 0)
                    {
                        candidates.Add(t);
                    }
                }
            }

            if (candidates.Count == 1)
            {
                return candidates[0];
            }

            if (candidates.Count == 0)
            {
                throw new Exceptions.UnresolvableTypeException(type);
            }

            var all = candidates.ToArray();
            candidates.Clear();
            foreach (var t in all)
            {
                var exports = t.GetCustomAttributes(Types.ExportAttribute, false).ToArray();
                foreach (var exported in exports)
                {
                    if (exported != null && (Type)exported.GetType().GetProperty("Type").GetValue(exported) == type)
                    {
                        candidates.Add(t);
                    }
                }
            }

            if (candidates.Count == 1)
            {
                return candidates[0];
            }

            throw new Exceptions.MultiImplementationOfSameInterfaceException(type);
        }

        private static System.Reflection.ConstructorInfo GetConstructor(Type type)
        {
            var constructors = type.GetConstructors(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
            if (constructors.Length == 1)
            {
                return constructors[0];
            }

            if (constructors == null || constructors.Length == 0)
            {
                return null;
            }

            List<System.Reflection.ConstructorInfo> candidates = new List<System.Reflection.ConstructorInfo>();
            foreach (var c in constructors)
            {
                var ca = c.GetCustomAttributes(Types.ImportingConstructorAttribute, false).FirstOrDefault();
                if (ca != null)
                {
                    candidates.Add(c);
                }
            }
            if (candidates.Count == 1)
            {
                return candidates[0];
            }

            throw new Exceptions.UnresolvableConstructorException(type);
        }

        private static bool ReturnIfOk(Type from, TypeCache result)
        {
            if (from.IsInterface && !from.IsAssignableFrom(result.ToType))
            {
                throw new Exceptions.TypeMismatchException(from, result.ToType);
            }
            return true;
        }


        private static bool ReturnIfImplemented(Type from, TypeCache result)
        {
            if (from.IsInterface && !from.IsAssignableFrom(result.ToType))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region private helpers
        private void ResolveProperties()
        {
            if (this.FromType.Inheriting(typeof(Microsoft.Xrm.Sdk.Entity)))
            {
                this.AllProperties = true;
                return;
            }

            if (this.ToType.Inheriting(typeof(Microsoft.Xrm.Sdk.Entity)))
            {
                this.FilteredProperties = CommonProperty.ForType(this.FromType, this.ToType);
            }
        }
        #endregion

        #region properties
        public Type FromType { get; private set; }
        public Type ToType { get; private set; }
        public string Name { get; private set; }
        public System.Reflection.ConstructorInfo Constructor { get; private set; }
        public bool IsGenericEntityInterface { get; private set; }
        public bool IsImplemenedByEntity { get; private set; }
        public bool IsTarget { get; private set; }
        public bool IsReference { get; private set; }
        public bool IsActionReference { get; private set; }
        public bool IsPreimage { get; private set; }
        public bool IsMergedimage { get; private set; }
        public bool IsPostimage { get; private set; }
        public string LogicalName { get; private set; }
        public bool IsQuery { get; private set; }
        public bool RequireAdminService { get; private set; }
        public bool AllProperties { get; private set; }
        public CommonProperty[] FilteredProperties { get; private set; }

        private CommonProperty[] _targetFilterProperties;
        public CommonProperty[] TargetFilterProperties
        {
            get
            {
                if (_targetFilterProperties == null)
                {
                    if (FilteredProperties == null)
                    {
                        _targetFilterProperties = new CommonProperty[0];
                        return _targetFilterProperties;
                    }
                    _targetFilterProperties = (from f in this.FilteredProperties
                                               where f.TargetFilter
                                               select f).ToArray();
                }
                return _targetFilterProperties;
            }
        }

        public bool RequirePluginContext
        {
            get
            {
                return IsTarget || IsReference || IsPreimage || IsPostimage || IsMergedimage;
            }
        }

        public bool IsInputParameter { get; set; }

        private System.Reflection.PropertyInfo _repositoryProperty;
        public System.Reflection.PropertyInfo RepositoryProperty
        {
            get
            {
                if (_repositoryProperty != null)
                {
                    return _repositoryProperty;
                }

                var repositoryType = Types.Instance.IRepository.GetGenericTypeDefinition();
                var entityType = this.ToType.GetGenericArguments()[0];
                var queryType = repositoryType.MakeGenericType(entityType);

                var uowTC = TypeCache.ForUow(this.RequireAdminService);

                var properties = uowTC.ToType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance)
                                        .Where(r => r.PropertyType == queryType).ToArray();

                if (properties.Length == 0)
                {
                    throw new Exceptions.UnresolvableTypeException(this.ToType);
                }

                if (properties.Length > 1)
                {
                    throw new Exceptions.MultiImplementationOfSameInterfaceException(this.ToType);
                }

                this._repositoryProperty = properties[0];
                return _repositoryProperty;
            }
        }

        private System.Reflection.MethodInfo _queryMethod;
        public System.Reflection.MethodInfo QueryMethod
        {
            get
            {
                if (this._queryMethod == null)
                {
                    var repository = this.RepositoryProperty;
                    this._queryMethod = repository.PropertyType.GetMethod("GetQuery", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                    if (this.QueryMethod == null)
                    {
                        throw new Exceptions.UnresolvableTypeException(this.ToType);
                    }
                }
                return this._queryMethod;
            }
        }

        private string _ik;
        public string ObjectInstanceKey
        {
            get
            {
                if (_ik == null)
                {
                    if (this.IsTarget) this._ik = "target:" + this.ToType.FullName;
                    else if (this.IsPreimage) this._ik = "preimage:" + this.ToType.FullName;
                    else if (this.IsMergedimage) this._ik = "mergedimage:" + this.ToType.FullName;
                    else if (this.IsPostimage) this._ik = "postimage:" + this.ToType.FullName;
                    else if (this.IsReference) this._ik = "ref:" + this.ToType.FullName;
                    else if (this.FromType.Implements(Types.IAdminUnitOfWork))
                    {
                        this._ik = Types.IAdminUnitOfWork.FullName;
                        this.RequireAdminService = true;
                    }
                    else if (this.FromType == typeof(Microsoft.Xrm.Sdk.IOrganizationService))
                    {
                        if (this.RequireAdminService)
                        {
                            this._ik = this.FromType.FullName + ":admin";
                        }
                        else
                        {
                            this._ik = this.FromType.FullName;
                        }
                    }
                    else if (this.IsQuery)
                    {
                        if (this.RequireAdminService)
                        {
                            return this.ToType.FullName + ":admin";
                        }
                        return this.ToType.FullName;
                    }
                    else if (this.FromType.Implements(Types.IAdminUnitOfWork)) this._ik = Types.IAdminUnitOfWork.FullName;
                    else if (this.FromType.Implements(Types.IUnitOfWork)) this._ik = Types.IUnitOfWork.FullName;
                    else if (this.FromType == typeof(Guid)) return $"GUID:{this.Name}";
                    else if (this.ToType != null) this._ik = this.ToType.FullName;
                    else this._ik = this.FromType.FullName;
                }
                return _ik;
            }
        }
        #endregion

        #region cache key
        private class Key
        {
            internal System.Reflection.ParameterInfo Parameter { get; set; }
            internal string LogicalName { get; set; }

            public override bool Equals(object obj)
            {
                var other = obj as Key;
                if (other != null)
                {
                    return other.LogicalName == this.LogicalName && other.Parameter == this.Parameter;
                }
                return false;
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    int hash = 17;
                    // Suitable nullity checks etc, of course :)
                    hash = hash * 23 + Parameter.GetHashCode();
                    if (LogicalName != null)
                    {
                        hash = hash * 23 + this.LogicalName.GetHashCode();
                    }
                    return hash;
                }
            }
        }
        #endregion
    }


    public static class TypeCacheLocalExtensions
    {
        public static bool Inheriting(this Type value, Type other)
        {
            if (value.BaseType == other)
            {
                return true;
            }

            if (value.IsSubclassOf(other))
            {
                return true;
            }

            if (value.BaseType != null)
            {
                return value.BaseType.Inheriting(other);
            }
            return false;
        }

        public static bool Implements(this Type value, Type other)
        {
            var intf = value.GetInterfaces();
            return intf != null && intf.Contains(other);
        }

        public static Type ImplementsGenericInterface(this Type value, Type other)
        {
            if (other == null)
            {
                return null;
            }

            if (!other.IsGenericType)
            {
                return null;
            }

            var match = value.GetInterfaces()
                .Where(i => i.IsGenericType)
                .FirstOrDefault(i => i.GetGenericTypeDefinition() == other);

            if (match != null)
            {
                return match.GetGenericArguments()[0];
            }

            return null;
        }

        public static bool IsITarget(this Type fromType)
        {
            var propertytype = TypeCache.Types.ITarget;
            return propertytype.IsAssignableFrom(fromType);
        }

        public static bool ExtendsGenericClassOf(this Type toCheck, Type generic)
        {
            while (toCheck != null && toCheck != typeof(object))
            {
                var cur = toCheck.IsGenericType ? toCheck.GetGenericTypeDefinition() : toCheck;
                if (generic == cur)
                {
                    return true;
                }
                toCheck = toCheck.BaseType;
            }
            return false;
        }

        public static bool MatchPattern(this System.Reflection.ParameterInfo parameter, Type customAttribute, string attributeName)
        {
            if (parameter == null)
            {
                return false;
            }
            var hasCA = parameter.GetCustomAttributes(customAttribute, false).Any();
            if (hasCA)
            {
                return true;
            }

            return !string.IsNullOrEmpty(attributeName) && parameter.Name.ToLower().Equals(attributeName.ToLower());
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Reflection\Types.cs
namespace Kipon.Tools.Xrm.Reflection
{
    using System;
    using System.Linq;
    using System.Collections.Generic;

    public sealed class Types
    {
        public static readonly string[] MESSAGE_WITHOUT_PRIMARY_ENTITY = new string[]
        {
            "AddMember",
            "RemoveMember"
        };


        private const string NAMESPACE = "Kipon" + "." + "Xrm" + ".";
        private Dictionary<string, Type> entityTypes = new Dictionary<string, Type>();

        private static Types _instance;

        static Types()
        {
            _instance = new Types();
        }

        private Types()
        {
        }


        public static Types Instance
        {
            get
            {
                return _instance;
            }
        }

        public void SetAssembly(System.Reflection.Assembly assembly)
        {
            this.Assembly = assembly;
            var allTypes = assembly.GetTypes().ToDictionary(r => r.FullName);

            this.TargetAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.TargetAttribute)}"];
            this.TargetFilterAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.TargetFilterAttribute)}"];
            this.PreimageAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.PreimageAttribute)}"];
            this.MergedimageAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.MergedimageAttribute)}"];
            this.PostimageAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.PostimageAttribute)}"];
            this.AdminAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.AdminAttribute)}"];
            this.ExportAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.ExportAttribute)}"];
            this.ImportingConstructorAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.ImportingConstructorAttribute)}"];
            this.RequiredAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.RequiredAttribute)}"];
            this.StepAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.StepAttribute)}"];
            this.LogicalNameAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.LogicalNameAttribute)}"];
            this.SortAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.SortAttribute)}"];
            this.OutputAttribute = allTypes[$"{NAMESPACE}Attributes.{nameof(_instance.OutputAttribute)}"];

            this.AbstractActionRequest = allTypes[$"{NAMESPACE}Actions.{nameof(_instance.AbstractActionRequest)}"];

            this.ITarget = allTypes[$"{NAMESPACE}{nameof(_instance.ITarget)}"];
            this.Target = allTypes[$"{NAMESPACE}{nameof(_instance.Target)}`1"];
            this.TargetReference = allTypes[$"{NAMESPACE}{nameof(_instance.TargetReference)}`1"];
            this.Preimage = allTypes[$"{NAMESPACE}{nameof(_instance.Preimage)}`1"];
            this.Mergedimage = allTypes[$"{NAMESPACE}{nameof(_instance.Mergedimage)}`1"];
            this.Postimage = allTypes[$"{NAMESPACE}{nameof(_instance.Postimage)}`1"];
            this.ActionTarget = allTypes[$"{NAMESPACE}{nameof(_instance.ActionTarget)}`1"];

            this.IUnitOfWork = allTypes[$"{NAMESPACE}{nameof(_instance.IUnitOfWork)}"];
            this.IAdminUnitOfWork = allTypes[$"{NAMESPACE}{nameof(_instance.IAdminUnitOfWork)}"];

            this.IRepository = allTypes[$"{NAMESPACE}{nameof(_instance.IRepository)}`1"];

            this.BasePlugin = allTypes[$"{NAMESPACE}{nameof(_instance.BasePlugin)}"];
            this.VirtualEntityPlugin = allTypes[$"{NAMESPACE}{nameof(_instance.VirtualEntityPlugin)}"];

            this.IPluginContext = allTypes[$"{NAMESPACE}{nameof(_instance.IPluginContext)}"];
        }

        public Type TargetAttribute { get; private set; }
        public Type PreimageAttribute { get; private set; }
        public Type MergedimageAttribute { get; private set; }
        public Type PostimageAttribute { get; private set; }
        public Type AdminAttribute { get; private set; }
        public Type ExportAttribute { get; private set; }
        public Type ImportingConstructorAttribute { get; private set; }
        public Type RequiredAttribute { get; private set; }
        public Type StepAttribute { get; private set; }
        public Type LogicalNameAttribute { get; private set; }
        public Type SortAttribute { get; private set; }
        public Type OutputAttribute { get; private set; }
        public Type ITarget { get; private set; }
        public Type Target { get; private set; }
        public Type TargetReference { get; private set; }
        public Type TargetFilterAttribute { get; private set; }
        public Type Preimage { get; private set; }
        public Type Mergedimage { get; private set; }
        public Type Postimage { get; private set; }
        public Type ActionTarget { get; private set; }
        public Type IUnitOfWork { get; private set; }
        public Type IAdminUnitOfWork { get; private set; }
        public Type IRepository { get; private set; }

        public Type AbstractActionRequest { get; private set; }

        public System.Reflection.Assembly Assembly { get; private set; }

        public Type BasePlugin { get; private set; }
        public Type VirtualEntityPlugin { get; private set; }

        public Type IPluginContext { get; private set; }

        public Type EntityTypeFor(string logicalname)
        {
            if (entityTypes.ContainsKey(logicalname))
            {
                return entityTypes[logicalname];
            }

            if (this.Assembly != null)
            {

                var allTypes = this.Assembly.GetTypes().Where(r => r.BaseType == typeof(Microsoft.Xrm.Sdk.Entity));
                foreach (var type in allTypes)
                {
                    var name = (Microsoft.Xrm.Sdk.Client.EntityLogicalNameAttribute)type.GetCustomAttributes(typeof(Microsoft.Xrm.Sdk.Client.EntityLogicalNameAttribute), false).SingleOrDefault();
                    if (name != null)
                    {
                        entityTypes[name.LogicalName] = type;
                    }
                }

                if (entityTypes.ContainsKey(logicalname))
                {
                    return entityTypes[logicalname];
                }
            }
            throw new Exceptions.UnknownEntityTypeException(logicalname);
        }

        public Type TypeForInterface(Type intf)
        {
            return this.Assembly.GetTypes().Where(t => t.Implements(intf)).Single();
        } 

    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\ServiceAPI\INamingService.cs
namespace Kipon.Tools.Xrm.ServiceAPI
{
    public interface INamingService
    {
        /// <summary>
        /// If refid is not null, but name is null, the service will try to populate the name from the SDK, and return the result. 
        /// If found the name will also be populated in refid.Name
        /// If Name is already populated on the entityreference, that name will be return.
        /// </summary>
        /// <param name="refid">Reference to lookup name for</param>
        /// <returns>null or name of the eference instance</returns>
        string NameOf(Microsoft.Xrm.Sdk.EntityReference refid);

        /// <summary>
        /// Returns the primary attributeid for the entity
        /// </summary>
        /// <param name="entitylogicalname"></param>
        /// <returns></returns>
        string PrimaryAttributeId(string entitylogicalname);

        /// <summary>
        /// returns the attribute name that carries the name of the entity.
        /// </summary>
        /// <param name="entitylogicalname"></param>
        /// <returns></returns>
        string PrimaryAttributeName(string entitylogicalname);
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Services\NamingService.cs

namespace Kipon.Tools.Xrm.Extensions.Sdk
{
    using Microsoft.Xrm.Sdk;

    public partial class NamingService : ServiceAPI.INamingService
    {
        private readonly IOrganizationService organizationService;
        private static System.Collections.Generic.Dictionary<string, Meta> metas = new System.Collections.Generic.Dictionary<string, Meta>();

        public NamingService([Attributes.Admin]IOrganizationService organizationService)
        {
            this.organizationService = organizationService;
        }

        public string NameOf(EntityReference refid)
        {
            if (refid == null)
            {
                return null;
            }

            if (!string.IsNullOrEmpty(refid.Name))
            {
                return refid.Name;
            }

            if (metas.TryGetValue(refid.LogicalName, out Meta m))
            {
                var result = this.organizationService.Retrieve(refid.LogicalName, refid.Id, new Microsoft.Xrm.Sdk.Query.ColumnSet(m.PrimaryAttributeName));
                refid.Name = result[m.PrimaryAttributeName] as string;
                return refid.Name;
            }
            return null;
        }

        public string PrimaryAttributeId(string entitylogicalname)
        {
            if (metas.TryGetValue(entitylogicalname, out Meta m))
            {
                return m.PrimaryAttributeId;
            }
            return null;
        }
        public string PrimaryAttributeName(string entitylogicalname)
        {
            if (metas.TryGetValue(entitylogicalname, out Meta m))
            {
                return m.PrimaryAttributeName;
            }
            return null;
        }

        private static void Add(string entitylogicalname, string entityattributeid, string entityattributename)
        {
            metas.Add(entitylogicalname, new Meta { PrimaryAttributeId = entityattributeid, PrimaryAttributeName = entityattributename });
        }

        private class Meta
        {
            internal string PrimaryAttributeId;
            internal string PrimaryAttributeName;
        }
    }
}

#endregion
#region source: ..\..\Kipon.Solid.Plugin\Xrm\Services\PluginContext.cs
namespace Kipon.Tools.Xrm.Services
{
    using Microsoft.Xrm.Sdk;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    internal class PluginContext : IPluginContext
    {
        private IPluginExecutionContext PluginExecutionContext;

        internal PluginContext(string unsecureConfig, string secureConfig, IPluginExecutionContext pluginExecutionContext, CrmEventType eventType, Guid userid)
        {
            this.UnsecureConfig = unsecureConfig;
            this.SecureConfig = secureConfig;
            this.PluginExecutionContext = pluginExecutionContext;
            this.EventType = eventType;
            this.UserId = userid;
        }

        public string UnsecureConfig { get; private set; }
        public string SecureConfig { get; private set; }
        public CrmEventType EventType { get; private set; }
        public Guid UserId { get; private set; }

        public bool AttributeChanged(params string[] names)
        {
            if (names == null || names.Length == 0)
            {
                return false;
            }
            if (PluginExecutionContext.InputParameters.Contains("Target"))
            {
                var dy = PluginExecutionContext.InputParameters["Target"] as Microsoft.Xrm.Sdk.Entity;

                if (dy != null)
                {
                    foreach (var name in names)
                    {
                        if (dy.Attributes.Contains(name))
                        {
                            return true;
                        }

                        if (!string.IsNullOrEmpty(name) && dy.Attributes.Contains(name.ToLower()))
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
            else
            {
                return false;
            }
        }
    }
}

#endregion
